[["index.html", "Notes for SCMA450: Data Modeling and Computing Chapter 1 Overview of Business Analytics and R Programming", " Notes for SCMA450: Data Modeling and Computing Dr. Liang (Leon) Xu 2021-08-25 Chapter 1 Overview of Business Analytics and R Programming Ever wondered how much data is created every day? Or perhaps youre keen to know how much data the average person uses at home? Thanks to the invention of mobile technology like smartphones and tablets, along with innovations in mobile networks and WiFi, the creation and consumption of data are constantly growing. In fact, there are 2.5 quintillion bytes of data created each day at our current pace, but that pace is only accelerating with the growth of the Internet of Things (IoT). To put things in perspective, Google on average processes more than 40,000 searches EVERY second (3.5 billion searches per day); Snapchat users share 527,760 photos every minute of the day; Users watch 4,146,600 YouTube videos every minute of the day; We send 16 million text messages and 103,447,520 spam emails every minute. Once you are aware of all the data you create as a single individual, you can start to imagine just how much data we collectively generate every single day. With such a tremendous amount data generated, the business world demands people equipped with the tools to analyze big data. In particular, data Analytics is a scientific process of combining data and models into insights for the purpose of making better decisions. For example, Netflix sets up an open competition to improve its algorithm to predict users rating of a movie, with a prize of 1million dollars. Similarly, Zillow (a real estate market place company) hosts a open competition with prize of 1million dollars to improve its prediction for house price. The scope of business analytics includes Descriptive Analytics: Condense tabular data into charts/reports/dashboard to be understandable. Predictive Analytics: use historical data to predict future. Prescriptive Analytics: Prescribe an action a business should take. The job market is also great for students with business analytical skills. Based on the search on keyword data analytics on Indeed.com in May 2020, the data analytics field has greatest amount of position in US. So, what are the skills needed to be competitive in the business analytical position? We have survey the data scientists and marketing analytics at Ameritas (a large insurance company). This is their response: If a course is focusing on data visualization, then I would highly recommend Tableau. If they are looking at data cleansing, then teaching either R or Python to their students, even on an introductory level, will give them a considerable boost when looking for positions. An in-depth understanding of Microsoft Excel should be understood, but it is much harder to recreate accessible and powerful commands in R or Python. In this course, we will focus on business analytical application with R. We will also talk a little about Python to give you a taste of the two different programming languages. Once you finished the course, we will fall in love with R because it is such a powerful tool for analyzing big data. R is a free software environment for statistical computing and graphics. R has the richest packages to perform data analysis. Around 12,000 packages available in CRAN (Comprehensive R Archive Network, open-source repository of R packages). R is open source: you can use the 12,000 packages for free! It compiles and runs on a wide variety of UNIX platforms, Windows and MacOS. To download R, please choose your preferred CRAN mirror at: https://www.r-project.org/. RStudio is an Integrated Development Environment (IDE) for R, a programming language for statistical computing and graphics. You can write and run R code with Rstudio. Here is the website to download Rstudio: https://www.rstudio.com/products/rstudio/download/. The objective of this course is: Get excited about writing code! This is one of my most important goal since we have the stereotype that business major only know to write ppt, not code. This is not true. Everyone should learn to code in the 21th century. Learn the R syntax. Just like a language, R is a computer language and we need to know the basic grammar R language to be able to give instruction to computers. Write R Code for Data Analytics Independently. It is common that students follow along well in class, but cannot write code independently. So we will have many exercise to help you code independently. "],["chapter01.html", "Chapter 2 Define Variables 2.1 Use R as a Calculator 2.2 Define variables 2.3 Basic Variable Modes: integer, numeric, character, logical, factor. 2.4 Exercise 1: Greeting from R 2.5 Exercise 2: Mortgage Calculation 2.6 Summary", " Chapter 2 Define Variables Here is the guideline in how to read this document: The shaded area (with green backgroud) is R code. Within the shaded area, # The hashtag means This is a comment. The comment is to help yourself and others to understand what the code does. The line right next to the code (starting with ##) is the output of the code. 2.1 Use R as a Calculator R can be used as a powerful calculator by entering equations directly at the prompt in the command console. Simply type your arithmetic expression and press ENTER. # R is highly interactive, you can get instant feedback while coding. 3+6 ## [1] 9 # To execute the above command, put the mouse anywhere in the line and hit &quot;Ctrl+Enter&quot;. # the product of 2 and 4 2*4 ## [1] 8 # 6 divided by 7 6/7 ## [1] 0.8571429 # 2 to the power of 10 2^10 ## [1] 1024 # x%%y return the reminder of x divided by y 10%%3 ## [1] 1 2.2 Define variables The most basic concept in programming is variable. A variable allows you to store a value (e.g. 4) or an object (e.g. a function) in R; and you can then later use this variables name to easily access the value or the object that is stored within this variable. The &lt;- symbol (&lt; and -) or = symbol means Set the variable on the left equal to the thing on the right. In RStudio the keyboard shortcut for the assignment operator &lt;- is Alt + - (Windows) or Option + - (Mac). For example, you can save you age to a varaible my_age through the following code: # Assign the variable &quot;my_age&quot; the value of 30. # The &quot;&lt;-&quot; or &quot;=&quot; symbol assigns right hand side (RHS) to the left hand side(LHS) my_age&lt;-30 You have just defined a variable my_age with value of 30, which is stored in the computer now. Now look at the up right corner of R-studio, you should see the defined variable. To print my_age on the screen, type in my_age (without quotes) and hit Ctrl+Enter. It will show you the value. my_age ## [1] 30 Or we can use the print() function to print the variable on the screen. print(my_age) ## [1] 30 Now, you need to define two more variables to save the age of the father and mother: mother_age with value of 60, and father_age with value of 65. mother_age&lt;-60 father_age&lt;-65 The defined the variables are saved in computer memory, and you can use the defined variable for calculation. # How much the father is older than the child? father_age-my_age ## [1] 35 # How much the father is older than the mother? father_age-mother_age ## [1] 5 We can define a new variable through the calculation on the existing variables. Define a variable avg_age with the value the average age of the parents. avg_age=(father_age+mother_age)/2 avg_age ## [1] 62.5 Variable names are like our human names, which uniquely identify the value stored in computer. It is best practice to use variable names that can be easily understood. Try to use English word and \"_\" to make it self-explanatory. Also, try to use lower case consistently because R is case-sensitivity. It will be hard to remember which letter is upper case and which is not. 2.3 Basic Variable Modes: integer, numeric, character, logical, factor. In the physical world, we have different mode of data. E.g., 30 is a an integer (a more specific type of numeric); 51.67 is a number; Leon is a character; TRUE/FALSE is logical; The color like blue/green/red is categorical. In R such categorical variable is called factor. R use different variable mode to store these different type of data. 2.3.1 Integer and numeric Recall that we define my_age as a number. Type class(my_age) to checkt the model of the variable. Note: class(): is a built-in R function which returns the mode of a variable. We will talk later what is function. # Type class(my_age) to check the mode of variable &quot;my_age&quot; class(my_age) ## [1] &quot;numeric&quot; To specifically define a variable as an integer, add letter L after the number. Define my_age=30L and check its mode. my_age=30L class(my_age) ## [1] &quot;integer&quot; You may be wondering why bother to differentiate integer and numeric; after all, they are all numbers. However, there is an important thing to remember: computer uses combination of 0/1 to save any values. While integer can always be exactly represented in 0/1 byte, non-integer may not be and thus lead to rounding error. Lets look at one example. It should be a no-brainer that sqrt(3)^2 should equals to 3. However, this is not the case in R (or any other programming languages). Try sqrt(3)^2==3 to compare these two number and see the result: # == is the logical operator to compare whether LHS equals RHS sqrt(3)^2==3 ## [1] FALSE Surprisingly, the output is FALSE, i.e., the computer makes a verdict that sqrt(3)^2 does not equal 3. This is because computer first computes sqrt(3), which is a non-integer with infinite decimal. To save this number in memory, sqrt(3) will be rounded. As a result, its square is not exactly 3. But in most cases, we do not need to overly concerned about rounding errors because the difference is negligible. 2.3.2 Logical In the above example, we introduced the logical operator == to compare numbers. The logical operator returns logical variable which takes value of only TRUE or FALSE. The typical Logical Operators in R: Operator Description &lt; less than &lt;= less than or equal to &gt; greater than &gt;= greater than or equal to == exactly equal to != not equal to !x Not x x | y x OR y x &amp; y x AND y isTRUE(x) test if X is TRUE Now, lets check the mode of the result of the comparison sqrt(3)^2==3 using the class() function. class(sqrt(3)^2==3) ## [1] &quot;logical&quot; Similarly, you define a logical variable by assigning the comparison results into a logical variable # type 3&gt;2 and assign the value to a variable compare # check the variable class of the variable compare compare&lt;-3&gt;2 compare ## [1] TRUE class(compare) ## [1] &quot;logical&quot; We can use &amp; (and) and | (or ) for logical calcuation. compare1&lt;-3==2 # 3 equals to 2 is FALSE compare2&lt;-3!=2 # 3 not equal to 2 is TRUE compare1 &amp; compare2 # x &amp; y: true only if both x and y are true; otherwise false. ## [1] FALSE compare1 | compare2 # x | y: false only if both x and y are false; otherwise true. ## [1] TRUE Now, compare the mother_age and father_age to see who is older? father_age&gt;mother_age ## [1] TRUE 2.3.3 Character Suppose we want to save my name into a variable, how can I do that? This involves a new type of variable: character (also known as string). The character variable is defined by \"; anything inside\" will be saved as the character. # Type my_name=&quot;Leon Xu&quot; and use class() to check its mode. my_name&lt;-&quot;Leon Xu&quot; my_name ## [1] &quot;Leon Xu&quot; class(my_name) ## [1] &quot;character&quot; Now, you need to define character variable first_name with value Leon; and define character variable last_name with value Xu;. first_name=&quot;Leon&quot; last_name=&quot;Xu&quot; Given, the first and last name, we can combine the two strings into the full name. Note that the Arithmetic operators (+-*/) are not defined over strings. We need to use string-specific functions. You can use paste() function to concatenate the two string together. full_name=paste(first_name, last_name, sep=&quot; &quot;) # sep=&quot; &quot; means to seperates the strings with a space. full_name ## [1] &quot;Leon Xu&quot; type ?paste to get the help document on this function. ?paste Again, string is defined using \"\". To better understand that, run the following code to see the difference: print(10+1) print(&quot;10+1&quot;) print(leon xu) print(10+1): 10+1 is not inside \"\", so computer will read and interpret 10+1 and return 11 as the result. print(10+1): 10+1 is insdie \"\", so computer knows this is a strings and will not interpret it and keep it intact. print(leon xu): leon xu is not inside \"\"; so computer will read it and try to interpret it. Because computer (which is good at number and computation) cannot understand the string, thus returns error. It is one of the most common mistake to forget \"\" when you actually means to define a character. 2.3.4 Type coercion Sometime we need to convert from one variable mode to another. This typically happens when we read data from computer or web (e.g., csv) into R because computer is not smart enough to guess the variable type correctly. The good news is that we can easily convert from one variable mode to another. e.g., define the following two variables: var1=&quot;3&quot; # this is a character var2=4 # this is a numeric class(var1) ## [1] &quot;character&quot; class(var2) ## [1] &quot;numeric&quot; # Type var1+var2 and run the code; this will cause an error because var1 is a character var1+var2 The code below shows how to convert a character to numeric. var1&lt;-as.numeric(var1) var1+var2 ## [1] 7 The type coercion functions: # convert character &quot;4&quot; to 4; as.numeric(&quot;4&quot;) ## [1] 4 # convert 4 to character &quot;4&quot; as.character(4) ## [1] &quot;4&quot; # convert logical to numeric as.numeric(FALSE) # FALSE is stored as 0 in the computer ## [1] 0 as.numeric(TRUE) # TRUE is stored as 1 in the computer ## [1] 1 # we can sum TRUE/FALSE since they are saved as 1/0 TRUE+TRUE+FALSE ## [1] 2 We cannot force type coercion when the it is clearly not possible. For example, we cannot change the character John to a number. In this case, the R will generate NA (missing value in R) var&lt;-as.numeric(&quot;John&quot;) # var will be assigned NA (not available) ## Warning: NAs introduced by coercion # is.na() is R function to check whether a variable is NA is.na(var) ## [1] TRUE # NA is contagious in R; operations over NA results in NA var+1 ## [1] NA In R programming, everything stored in your computer are Objects. The variable we defined are also objects. Look for your objects in the upper right of the RStudio area # type ls() to see the objects stored in the computer ls() ## [1] &quot;avg_age&quot; &quot;compare&quot; &quot;compare1&quot; &quot;compare2&quot; &quot;father_age&quot; ## [6] &quot;first_name&quot; &quot;full_name&quot; &quot;jobData&quot; &quot;keyword&quot; &quot;last_name&quot; ## [11] &quot;mother_age&quot; &quot;my_age&quot; &quot;my_name&quot; &quot;position&quot; &quot;var&quot; ## [16] &quot;var1&quot; &quot;var2&quot; # you can remove objects through rm(). Remove the variable firstname rm(var) 2.4 Exercise 1: Greeting from R In this exercise, we will create a customized greeting from R to you. We will write a code to let the computer ask your name and age and print a customized greeting. This seems first overwhelming. In computer programming, one philosophy is always to break a complicated task into small piece and build upon that. Lets do the version 1: # Send a customized greeting based on your name (e.g., Leon) and age (e.g., 30) # Suppose it takes 1 year to master R programming print(&quot;Hello Leon, welcome to the world of R!&quot;) ## [1] &quot;Hello Leon, welcome to the world of R!&quot; print(&quot;You will be empowered by R to do awesome data analytics by the age 31!&quot;) ## [1] &quot;You will be empowered by R to do awesome data analytics by the age 31!&quot; Well, this is simple, but we need to customize so that it print your name and age information. Lets do the version 2: # Define your name and age (change to your name and age) name=&quot;Leon&quot; age=30 # Send a customized greeting based on your name and age # We need to paste the name and age to the greeting greeting1&lt;-paste(&quot;Hello &quot;, name, &quot;, welcome to the world of R!&quot;, sep = &quot;&quot;) greeting2&lt;-paste(&quot;You will be empowered by R to do awesome data analytics by the age &quot;, age+1, &quot;!&quot;, sep=&quot;&quot;) print(greeting1) ## [1] &quot;Hello Leon, welcome to the world of R!&quot; print(greeting2) ## [1] &quot;You will be empowered by R to do awesome data analytics by the age 31!&quot; Lets do the version 3: we will make it more interactive by using a function readline(), which asks for input from user through keyboard. # Use the console to input your name and age: name=readline(&quot;What is your name: &quot;) age=readline(&quot;How old are you: &quot;) # readline() always return a character age&lt;-as.numeric(age) # Send a customized greeting based on your name and age # We need to paste the name and age to the greeting greeting1&lt;-paste(&quot;Hello &quot;, name, &quot;, welcome to the world of R!&quot;, sep = &quot;&quot;) greeting2&lt;-paste(&quot;You will be empowered by R to do awesome data analytics by the age &quot;, age+1, &quot;!&quot;, sep=&quot;&quot;) print(greeting1) print(greeting2) 2.5 Exercise 2: Mortgage Calculation Support you are working at a bank provides mortgage loan. One important task is to calculate the monthly mortgage payment for any given loan. You can use the following equation to calculate the monthly mortgage payment (not including taxes and insurance): \\[M = P ( i(1 + i)^n ) / ( (1 + i)^n - 1)\\] where P = principal loan amount i = annual_interest_rate/12, i.e., i is the monthly interest rate, which is the annual interest rate divided by 12 n = number of months required to repay the loan Develop a program to calculate the monthly mortgage payment for a loan with: P=350000; annual_interest_rate=3.25%; year_repay=30. Once you calculate the monthly payment, print the result on the screen \"Your month mortgage payment is: ***\" # Define the loan P=350000 # loan amount annual_rate=0.0325 # Convert % into decimal to avoid error year_repay=30 # number of year to repay n=12*30 # number of month to repay i=annual_rate/12 payment = P*( i*(1 + i)^n ) / ( (1 + i)^n - 1) payment = round(payment,digits=0) print(paste(&quot;Your monthy mortage payment is $&quot;, payment, sep=&quot;&quot;)) ## [1] &quot;Your monthy mortage payment is $1523&quot; 2.6 Summary Learn to do basic arithmetic operations (+,-,*,/,^,%%) in R. Learn to define variable and the rule in naming variables. Understand the different variable mode (or type): integer, numeric, logical, character Understand how convert from one tpye to another. Learn to create the first interactive program using print() and readline() functions. "],["data-structure-vector-matrix-list-and-factor.html", "Chapter 3 Data Structure: Vector, Matrix, List and Factor 3.1 Vector 3.2 Matrices 3.3 Factors 3.4 List 3.5 Summary", " Chapter 3 Data Structure: Vector, Matrix, List and Factor It is ineffecicent to store each data point as a single-value variable. Think of dataset with 1000 rows and 20 columns, it will requires 20,000 single-value variables to store the data. In R, there are more efficient ways to store an array of data. Here we will introduce a few common data structure in R, including vector, matrix, data frame, and list. In addition, we all also talk about the factor: the data mode to represent categorical variable in R. 3.1 Vector Vector is a one-dimensional array that can hold numeric data, character data, or logical data. # Assign x the value c(1, 2, 3, 4, 10) (Here, &quot;c&quot; means vector) x=c(1,2,3,4,10) Notice that, after running the code, it seems nothing happen on the output screen. This is because this code only tells the computer to create a vector x with value of c(1, 2, 3, 4, 10). You can type x to print it on the screen. One simple trick to print x is to put the code inside () as follow: (x=c(1,2,3,4,10)) ## [1] 1 2 3 4 10 You can also create vector using a R-function seq(): y=seq(from=1, length=5, by=2), which creates a vector with length of 5, starting from 1 with step of 2. seq() is a very useful function to generate sequence, specially when we construct for loop. (y=seq(from=1,length=5,by=2)) ## [1] 1 3 5 7 9 # check the help document of the function by typing ?seq. Now, suppose you are at SpaceX launching center, you want to count down from 10 to 1. Use seq() to generate a sequence from 10 to 1. seq(from=10,length=10,by=-1) ## [1] 10 9 8 7 6 5 4 3 2 1 seq(from=10,to=1,by=-1) ## [1] 10 9 8 7 6 5 4 3 2 1 There is another quick way to generate a sequence of integer with interval of 1 using colon: # type 1:10 to define a vector from 1 to 10 with interval of 1. 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 # type 10:1 to define a vector from 10 to 1 with interval of -1. 10:1 ## [1] 10 9 8 7 6 5 4 3 2 1 So far, the element of a vector is numerical. The element of a vector can also be character or logical. # define a character vector b=c(&quot;one&quot;,&quot;two&quot;,&quot;three&quot;) b=c(&quot;one&quot;,&quot;two&quot;,&quot;three&quot;) b ## [1] &quot;one&quot; &quot;two&quot; &quot;three&quot; class(b) ## [1] &quot;character&quot; # define a logical vector c=c(TRUE,FALSE,FALSE) c=c(TRUE,FALSE,FALSE) c ## [1] TRUE FALSE FALSE class(c) ## [1] &quot;logical&quot; The element of a vector must be the same type. Otherwise, R will force type coercion: convert all elements into character. Of course, we should aviod such forced type coercion by making sure all elements in the vector are the same type. For example, type d=c(4,3) and e=c(a, TRUE) and then print these two vectors, which are forced to be converted to character. d=c(4,&quot;3&quot;) e=c(&quot;a&quot;, TRUE) d ## [1] &quot;4&quot; &quot;3&quot; e ## [1] &quot;a&quot; &quot;TRUE&quot; 3.1.1 Subsetting vectors The vector is like an one-dimensional container for data. Once we create the vector, we can retrieve the elements from the vector according to the index. # define x=c(1,2,3,4,10) x=c(1,2,3,4,10) # retrieve the 2rd element of x by typing x[2]. x[2] ## [1] 2 It is important to notice that [] is the operator for subsetting the vector. It is a common mistake to type x(2), which means calling the function named x and passing argument 2 to the function. You can also retrieve multiple element for a vector at the same time. # retrieve the 1st, 3rd and 5th element of x x[c(1,3,5)] ## [1] 1 3 10 # retrieve the 2rd to 5th elements of x using colon operator x[2:5] ## [1] 2 3 4 10 The negative index means to retrieve every element from a vector except the negative index one, e.g., # retrieve every element of x except the 2rd element x[-1] ## [1] 2 3 4 10 We can also retrieve elements from vector by logical operator. E.g., # retrieve elements of x that is less than 5 x[x&lt;5] ## [1] 1 2 3 4 We cannot retrieve element from a vector which is beyond its length. E.g., if you type x[6], that will return NA (i.e., missing value) because the x only have 5 elements. x[6] Thus, it is important to know the length of a vector to aviod such error. # Find the length of &quot;x&quot; using &quot;length(x)&quot; length(x) ## [1] 5 3.1.2 Vector calculus We can perform operation on vector just as we perform operation on their individual elements. E.g., when the element of vector is numeric, you can perform operation (+, -, *, /) on each element of a vector. n=4 x=c(1,2,3,4,10) # Multiply x * n x*n ## [1] 4 8 12 16 40 # divide x/n x/n ## [1] 0.25 0.50 0.75 1.00 2.50 # addition x+n x+n ## [1] 5 6 7 8 14 # minus x-n x-n ## [1] -3 -2 -1 0 6 # power x^n x^n ## [1] 1 16 81 256 10000 We can also perform operation (+,-,*,/) with two vectors x=c(1,2,3,4,10) y=1:5 # multiply x * y : the corresponding elements will multiply each other. x*y ## [1] 1 4 9 16 50 # divide x/y: the corresponding elements will divide each other. x/y ## [1] 1 1 1 1 2 # addition x+y: the corresponding elements will add each other. x+y ## [1] 2 4 6 8 15 # minus x-y: the corresponding elements will minus each other. x-y ## [1] 0 0 0 0 5 # x^y: the x to the power of the corresponding element in y x^y ## [1] 1 4 27 256 100000 We can also use built-in R function to get summry about a vector. # Find the mean, median, min, and max of the numebers in &quot;x&quot; mean(x) ## [1] 4 median(x) ## [1] 3 min(x) ## [1] 1 max(x) ## [1] 10 summary(x) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 1 2 3 4 4 10 3.2 Matrices A matrix is a two-dimensional array where each element has the same type (numeric, character, or logical). Matrices are created with the matrix function. The general format is: myymatrix = matrix(vector, nrow=number_of_rows, ncol=number_of_columns, byrow=logical_value, dimnames=list( char_vector_rownames, char_vector_colnames)) # type ?matrix to get the help document on matrix() ?matrix Lets make a matrix m=matrix(1:6, nrow = 3, ncol = 2). Note that we are not passing value to the arguments such as byrow and dimnames. In such case, the R will take the default value for these argumements. # with matrices, it always fills column by column by default. m = matrix(1:6, nrow = 3, ncol = 2) # print matrix m m ## [,1] [,2] ## [1,] 1 4 ## [2,] 2 5 ## [3,] 3 6 Now, find the dimension of m so that we can retrieve its element. # type dim(m) to get the rows and columns dim(m) ## [1] 3 2 # type nrow(m) and ncol(m) to get the rows and columns respectively nrow(m) ## [1] 3 ncol(m) ## [1] 2 We can fill the matrix by rows by setting byrow to be TRUE # create a matrix, filling by rows matrix(1:6,nrow=3, ncol=2, byrow=TRUE) ## [,1] [,2] ## [1,] 1 2 ## [2,] 3 4 ## [3,] 5 6 We can also stack multiple vector to become a matrix. Depending on whether we want to stack the vector by column or by row, we can use cbind() and rbind() function. # create matrix through column bind cbind(): m2=cbind(c(1,3,4) c(2,34,5)) m2=cbind(c(1,3,4),c(2,34,5)) m2 ## [,1] [,2] ## [1,] 1 2 ## [2,] 3 34 ## [3,] 4 5 # create matrix through row bind rbind: m3=rbind(c(1,3,4), c(2,34,5)) m3=rbind(c(1,3,4), c(2,34,5)) m3 ## [,1] [,2] [,3] ## [1,] 1 3 4 ## [2,] 2 34 5 3.2.1 subsetting matrix Matrix is a 2-dimensional container to store the data point. Once the matrix is defined, we can retrieve element from the matrix according to its index. # To retrieve the &quot;element&quot; in the second row and first column we # type &quot;m[2,1]&quot;. Again, the square brackets are used to retrieve part of a vector or matrix. # If we want the entire second column we type in &quot;m[,2]&quot;. This means &quot;all rows, second column 2&quot; # If we want the entire third row, we type in &quot;m[3,]&quot;. This means &quot;third row, all columns&quot; m[2,1] ## [1] 2 m[,2] ## [1] 4 5 6 m[3,] ## [1] 3 6 You can also retrieve elements from matrix using colon operator, e.g., # retrieve elements at row 1-2, and 2th column m[1:2,2] ## [1] 4 5 Similar to vector, elements of a matrix have to be the same type. otherwise, R will force type coercion. E.g., # define a matrix with numerics m4=matrix(1:8,ncol=2) m4 ## [,1] [,2] ## [1,] 1 5 ## [2,] 2 6 ## [3,] 3 7 ## [4,] 4 8 # define a matrix with character. char=matrix(c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;), nrow=4) char ## [,1] ## [1,] &quot;a&quot; ## [2,] &quot;b&quot; ## [3,] &quot;c&quot; ## [4,] &quot;d&quot; Now combine the two matrixes m4 and char through cbind() m5=cbind(m4,char) m5 ## [,1] [,2] [,3] ## [1,] &quot;1&quot; &quot;5&quot; &quot;a&quot; ## [2,] &quot;2&quot; &quot;6&quot; &quot;b&quot; ## [3,] &quot;3&quot; &quot;7&quot; &quot;c&quot; ## [4,] &quot;4&quot; &quot;8&quot; &quot;d&quot; All elements of the matrixes are converted to character. 3.2.2 matrix calculus You can perform operation (+, -, *, /) on each element of a vector. # Multiply m * n n=10 m = matrix(1:6, nrow = 3, ncol = 2) m*n ## [,1] [,2] ## [1,] 10 40 ## [2,] 20 50 ## [3,] 30 60 # divide x/n m/n ## [,1] [,2] ## [1,] 0.1 0.4 ## [2,] 0.2 0.5 ## [3,] 0.3 0.6 # addition x+n m+n ## [,1] [,2] ## [1,] 11 14 ## [2,] 12 15 ## [3,] 13 16 # minus x-n m-n ## [,1] [,2] ## [1,] -9 -6 ## [2,] -8 -5 ## [3,] -7 -4 We can also use the built-in R functions to perform matrix calcuation. The colSums and rowSums are two useful function for matrix. # type colSums(m) to obtain the sum of each column of matrix m colSums(m) ## [1] 6 15 # type rowSums(m) to obtain the sum of each row of matrix m rowSums(m) ## [1] 5 7 9 apply() is a handy function for matrix calcuation. The general format of apply() function is: apply(matrix, margin, function) margin=1 indicates applying each row of the matrix to the function. margin=2 indicate applying each column of the matrix to the function. # E.g., calculating the mean of each row apply(m,1,mean) ## [1] 2.5 3.5 4.5 # E.g., calculating the sum of each column apply(m,2,sum) ## [1] 6 15 3.3 Factors Many data are categorical: e.g., the patients diabetes type (type 1 or type 2), the movie type (action, sci-fi, comedy), the customer satisfaction level (poor, good excellent) to a call service. # define a vector of diabetes type diabetes = c(&quot;Type1&quot;, &quot;Type2&quot;, &quot;Type1&quot;, &quot;Type1&quot;) class(diabetes) ## [1] &quot;character&quot; We need to convert the diabetes vector into factor to represent that this is a categorical variable. We can do that through the factor() function: diabetes = factor(diabetes) class(diabetes) ## [1] &quot;factor&quot; str(diabetes) ## Factor w/ 2 levels &quot;Type1&quot;,&quot;Type2&quot;: 1 2 1 1 Note that str() is a very handy function in R. It examines the structure of any objects in R. We use this function to examine the factor. As shown, diabetes has two levels: Type1 and Type2. They are coded as 1 and 2 respectively. Take an another example. Suppose we are buidling a database for movies. The movie_type is the vector which stores the type of each movie in the database. # define a vector of movie type movie_type=c(&quot;sci-fi&quot;,&quot;comedy&quot;,&quot;sci-fi&quot;,&quot;action&quot;,&quot;action&quot;) str(movie_type) ## chr [1:5] &quot;sci-fi&quot; &quot;comedy&quot; &quot;sci-fi&quot; &quot;action&quot; &quot;action&quot; movie_type = factor(movie_type) str(movie_type) ## Factor w/ 3 levels &quot;action&quot;,&quot;comedy&quot;,..: 3 2 3 1 1 Note that both diabetes and movie are unordered because it does not make sense to compare each category in both cases. There are also situations we need ordered factor, i.e., age group, education level, etc. In marketing, we typically run customer satisfaction survey on a 1-5 scale, where 1 means poor, 2 fair, 3 good and 4 improved and 5 excellent. This is called ordered factor: they are categorical but you can compare different category. # Here is a vector of survey response from 6 different customers survey_response=c(1,3,5,2,3,5) # convert this vector into a vector of factor with the corresponding labels survey_response2=factor(survey_response,order=TRUE,levels=c(1,2,3,4,5),labels=c(&quot;poor&quot;,&quot;fair&quot;,&quot;good&quot;,&quot;improved&quot;, &quot;excellent&quot;)) survey_response2 ## [1] poor good excellent fair good excellent ## Levels: poor &lt; fair &lt; good &lt; improved &lt; excellent str(survey_response2) ## Ord.factor w/ 5 levels &quot;poor&quot;&lt;&quot;fair&quot;&lt;..: 1 3 5 2 3 5 In the above code, levels and labels describe the level and their corresponding labels for this categorical variable. Note you need to put levels in their ascending order. As seen, the original response is coded in 1-5. Without proper labels, it would be very difficult to understand what 1-5 means. Thus, the R Factor is very useful to deal with such coded categorical variables. Since this is a ordered factor, we can compare between different level survey_response2[1] # no longer a number, but a coded level. ## [1] poor ## Levels: poor &lt; fair &lt; good &lt; improved &lt; excellent survey_response2[2] ## [1] good ## Levels: poor &lt; fair &lt; good &lt; improved &lt; excellent # we can compare level since this is a ordered factor survey_response2[1]&gt;survey_response2[2] ## [1] FALSE As mentioned, everything in R (e.g., the variable we defined and the function) is an object. We can use str() to examine the structure of any objecxt. # use str() to examine data in R str(movie_type) ## Factor w/ 3 levels &quot;action&quot;,&quot;comedy&quot;,..: 3 2 3 1 1 str(survey_response2) ## Ord.factor w/ 5 levels &quot;poor&quot;&lt;&quot;fair&quot;&lt;..: 1 3 5 2 3 5 # use str() to examine function str(factor) ## function (x = character(), levels, labels = levels, exclude = NA, ordered = is.ordered(x), ## nmax = NA) str(str) ## function (object, ...) 3.4 List Lists are the most complex of the R data types. Basically, a list is an collection of all kinds of objects (components). The many complex function returns list as function output, thus it is very important to know this data structure. Create a list: list(obj1, obj2, ) obj1, obj2,  can be DIFFERENT data types. # type movielist=list(&quot;end game&quot;, 2019, 2783), # the 1st is movie title, the 2nd is year, the 3rd is box office movielist=list(&quot;end game&quot;, 2019, 2783) # print the list movielist ## [[1]] ## [1] &quot;end game&quot; ## ## [[2]] ## [1] 2019 ## ## [[3]] ## [1] 2783 # type str(movielist) to see its structure str(movielist) ## List of 3 ## $ : chr &quot;end game&quot; ## $ : num 2019 ## $ : num 2783 Name each objects in the list using names() function names(movielist)=c(&quot;title&quot;,&quot;year&quot;,&quot;boxoffice&quot;) movielist ## $title ## [1] &quot;end game&quot; ## ## $year ## [1] 2019 ## ## $boxoffice ## [1] 2783 It is a best practice to create list with variable name in the first place to enhance the readability of your code. movielist=list(title=&quot;end game&quot;, year=2019, boxoffice=2783) str(movielist) ## List of 3 ## $ title : chr &quot;end game&quot; ## $ year : num 2019 ## $ boxoffice: num 2783 We can also retrieve the element from list by index; however, we need to use DOUBLE square brackets for retrieve element in list!! # Type movielist[[2]] to retrieve the 2rd element movielist[[2]] ## [1] 2019 The objects in a list is named, we can also retrieve element from list by name. The $ is used to retrieve list element by name. movielist$title ## [1] &quot;end game&quot; Add an element to a list ia also very simple. For example, we want to add a duration of the movie, we can do type movielist$duration=3. movielist$duration=3 str(movielist) ## List of 4 ## $ title : chr &quot;end game&quot; ## $ year : num 2019 ## $ boxoffice: num 2783 ## $ duration : num 3 3.5 Summary The common data structure in R: vector, matrix, list learn to retrieve elements from vector or matrix with index learn to retrieve elements from list with [[]] or $. Learn to use factor to represent both ordered and unodered categorical variables. All elments in vector and matrix must be the same type; list can contain any different type of data. "],["data-frame.html", "Chapter 4 Data Frame 4.1 Define a data.frame manually 4.2 Subsetting data.frame 4.3 Import csv data as data.frame. 4.4 Subsetting data frame 4.5 Write a data frame to your computer 4.6 Summary", " Chapter 4 Data Frame A data frame is more general than a matrix in that different columns can contain different modes of data (numeric, character, factor, logical etc.). We can think of a data frame as a excel sheet where each row represents an observation, while each column represents a variable associated with the observation. Data frames are the basic data structure youll deal with in R. 4.1 Define a data.frame manually Our first exercise is to define a data frame manually to help you familize the functions related to data frame. Suppose we are building a database of diabetes patients. For simplicity, suppose we have only four patients, with the following patient information: patientID = c(1, 2, 3, 4) age = c(25, 34, 28, 52) diabetes = c(&quot;Type1&quot;, &quot;Type2&quot;, &quot;Type1&quot;, &quot;Type1&quot;) status = c(&quot;Poor&quot;, &quot;Median&quot;, &quot;Good&quot;, &quot;Poor&quot;) We want to combine these information into a data frame. The function to construct data fram is as below: mydata = data.frame(col1, col2, col3,) where col1, col2, col3,  are the column of the data frame. Names for each column can be provided with the names function. The following code makes this clear. # this create an empty data frame. # We sometime need to do that when we do not know the ultimate dimension of the data frame. patientdata = data.frame() patientdata = data.frame(patientID, age, diabetes, status) # display the data frame on the screen to visually check the dataset patientdata ## patientID age diabetes status ## 1 1 25 Type1 Poor ## 2 2 34 Type2 Median ## 3 3 28 Type1 Good ## 4 4 52 Type1 Poor We can use str() to examine the structure of the data frame. str() is a very useful function to examine an object in R. We will use this function often. str(patientdata) ## &#39;data.frame&#39;: 4 obs. of 4 variables: ## $ patientID: num 1 2 3 4 ## $ age : num 25 34 28 52 ## $ diabetes : chr &quot;Type1&quot; &quot;Type2&quot; &quot;Type1&quot; &quot;Type1&quot; ## $ status : chr &quot;Poor&quot; &quot;Median&quot; &quot;Good&quot; &quot;Poor&quot; Note that each column of a data frame must have have same data mode, but you can put columns of different modes together to form the data frame. Because data frames are close to what analysts typically think of as datasets, well use the terms columns and variables interchangeably when discussing data frames. 4.2 Subsetting data.frame There are several ways to identify the elements of a data frame. You can use the index notation you used before (for example, with matrices) or you can specify column names. Subset the first 2 column of the patientdata by index: patientdata[,1:2] ## patientID age ## 1 1 25 ## 2 2 34 ## 3 3 28 ## 4 4 52 Subset the first two columns of the data frame by variable names: patientdata[c(&quot;diabetes&quot;, &quot;status&quot;)] ## diabetes status ## 1 Type1 Poor ## 2 Type2 Median ## 3 Type1 Good ## 4 Type1 Poor Subset one specific column (e.g., age) by its name: patientdata$age ## [1] 25 34 28 52 Now, change diabetes and status into factors because they are categorical variables: patientdata$diabetes&lt;-factor(patientdata$diabetes) patientdata$status&lt;-factor(patientdata$status, ordered = TRUE, levels = c(&quot;Poor&quot;, &quot;Median&quot;,&quot;Good&quot;) ) patientdata ## patientID age diabetes status ## 1 1 25 Type1 Poor ## 2 2 34 Type2 Median ## 3 3 28 Type1 Good ## 4 4 52 Type1 Poor str(patientdata) ## &#39;data.frame&#39;: 4 obs. of 4 variables: ## $ patientID: num 1 2 3 4 ## $ age : num 25 34 28 52 ## $ diabetes : Factor w/ 2 levels &quot;Type1&quot;,&quot;Type2&quot;: 1 2 1 1 ## $ status : Ord.factor w/ 3 levels &quot;Poor&quot;&lt;&quot;Median&quot;&lt;..: 1 2 3 1 4.3 Import csv data as data.frame. In most application, we will import dataset (i.e., csv, txt, excel files) from local computer into R as data frame. Here we will learn how to read data into R as data frame. The famous Auto.csv is a very standard dataset for R programming. The Auto.csv contains the basic information of over 300 kinds of Auto. We will learn to import this dataset. I have uploaded the Auto.csv file in the R-studio cloud to aviod the trouble of finding the file in each individuals computer. Look at the files in the bottom right pannel. The file is in csv format, thus we will use read.csv() function. Auto=read.csv(&quot;data/Auto.csv&quot;) # examine the structure of Auto dataset str(Auto) ## &#39;data.frame&#39;: 392 obs. of 10 variables: ## $ mpg : num 18 15 18 16 17 15 14 14 14 15 ... ## $ cylinders : int 8 8 8 8 8 8 8 8 8 8 ... ## $ displacement: num 307 350 318 304 302 429 454 440 455 390 ... ## $ horsepower : int 130 165 150 150 140 198 220 215 225 190 ... ## $ weight : int 3504 3693 3436 3433 3449 4341 4354 4312 4425 3850 ... ## $ acceleration: num 12 11.5 11 12 10.5 10 9 8.5 10 8.5 ... ## $ year : int 70 70 70 70 70 70 70 70 70 70 ... ## $ rating : int 3 1 3 2 1 2 1 2 1 1 ... ## $ origin : chr &quot;US&quot; &quot;US&quot; &quot;US&quot; &quot;US&quot; ... ## $ name : chr &quot;chevrolet chevelle malibu&quot; &quot;buick skylark 320&quot; &quot;plymouth satellite&quot; &quot;amc rebel sst&quot; ... Unlikely excel which shows data in a tabular format, R uses different ways for us to visually examine the data. We can use head() and tail() to examine first/last 6 rows of the data. # print the first 6 rows for visually examining the dataset head(Auto) ## mpg cylinders displacement horsepower weight acceleration year rating origin ## 1 18 8 307 130 3504 12.0 70 3 US ## 2 15 8 350 165 3693 11.5 70 1 US ## 3 18 8 318 150 3436 11.0 70 3 US ## 4 16 8 304 150 3433 12.0 70 2 US ## 5 17 8 302 140 3449 10.5 70 1 US ## 6 15 8 429 198 4341 10.0 70 2 US ## name ## 1 chevrolet chevelle malibu ## 2 buick skylark 320 ## 3 plymouth satellite ## 4 amc rebel sst ## 5 ford torino ## 6 ford galaxie 500 tail(Auto) ## mpg cylinders displacement horsepower weight acceleration year rating ## 387 27 4 151 90 2950 17.3 82 2 ## 388 27 4 140 86 2790 15.6 82 3 ## 389 44 4 97 52 2130 24.6 82 3 ## 390 32 4 135 84 2295 11.6 82 3 ## 391 28 4 120 79 2625 18.6 82 2 ## 392 31 4 119 82 2720 19.4 82 4 ## origin name ## 387 US chevrolet camaro ## 388 US ford mustang gl ## 389 EU vw pickup ## 390 US dodge rampage ## 391 US ford ranger ## 392 US chevy s-10 We can use summary() function to quickly examine the distribution of each variable. summary(Auto) ## mpg cylinders displacement horsepower weight ## Min. : 9.00 Min. :3.000 Min. : 68.0 Min. : 46.0 Min. :1613 ## 1st Qu.:17.00 1st Qu.:4.000 1st Qu.:105.0 1st Qu.: 75.0 1st Qu.:2225 ## Median :22.75 Median :4.000 Median :151.0 Median : 93.5 Median :2804 ## Mean :23.45 Mean :5.472 Mean :194.4 Mean :104.5 Mean :2978 ## 3rd Qu.:29.00 3rd Qu.:8.000 3rd Qu.:275.8 3rd Qu.:126.0 3rd Qu.:3615 ## Max. :46.60 Max. :8.000 Max. :455.0 Max. :230.0 Max. :5140 ## acceleration year rating origin ## Min. : 8.00 Min. :70.00 Min. :1.00 Length:392 ## 1st Qu.:13.78 1st Qu.:73.00 1st Qu.:2.00 Class :character ## Median :15.50 Median :76.00 Median :2.00 Mode :character ## Mean :15.54 Mean :75.98 Mean :2.48 ## 3rd Qu.:17.02 3rd Qu.:79.00 3rd Qu.:3.00 ## Max. :24.80 Max. :82.00 Max. :4.00 ## name ## Length:392 ## Class :character ## Mode :character ## ## ## read.csv() is the function to read csv file into R as a data.frame. When using the function, you need to tell exactly where to find the data file. For example, if Auto.csv is saved in my computer at: C:/Users/lxu25/Dropbox/Teaching/UNL Courses/SCMA 450/code/Auto.csv. We can use the following code to read the file: Auto=read.csv(&quot;C:/Users/lxu25/Dropbox/Teaching/UNL Courses/SCMA 450/code/Auto.csv&quot;) Notice, in the the file directory is /, not \". However, locating this data file can be a hassle, especially when your code is shared with others in your team because the data has a totally different directory in otherss computer. Therefore, it is the best practice to always create a seperate folder for your project and save both code and data in that folder. Since your data is in the same folder of your code, we can simply use the filename to locate the data file. Then share the folder together to others. 4.4 Subsetting data frame Select by rows by index. # type Auto[2,] to select the 2nd row (or called 2nd observation) Auto[2,] ## mpg cylinders displacement horsepower weight acceleration year rating origin ## 2 15 8 350 165 3693 11.5 70 1 US ## name ## 2 buick skylark 320 # type Auto[c(3,5,7),] to select the 3rd, 5th, and 7th rows. Auto[c(3,5,7),] ## mpg cylinders displacement horsepower weight acceleration year rating origin ## 3 18 8 318 150 3436 11.0 70 3 US ## 5 17 8 302 140 3449 10.5 70 1 US ## 7 14 8 454 220 4354 9.0 70 1 US ## name ## 3 plymouth satellite ## 5 ford torino ## 7 chevrolet impala Select column by index. # type Auto[,4] to select the 4th column (i.e., horsepower); head(Auto[,4]) ## [1] 130 165 150 150 140 198 # tpye hist(Auto[,4]) to plot the distribution of horsepower hist(Auto[,4]) # You can customize the histgram to make it look nicer hist(Auto[,4],xlab=&quot;horsepower&quot;, col=&quot;gray&quot;,breaks = 50, main= &quot;frequency of horsepower&quot;) hist() plot the histogram of a variable. You can use ?hist to examine the detail of the function. ?hist # a quick way to look at how to use this function of We can select multiple columns (variables) at the same time. # select the 2nd and 4th column (i.e., cylinders and horsepower ) head(Auto[,c(2,4)]) ## cylinders horsepower ## 1 8 130 ## 2 8 165 ## 3 8 150 ## 4 8 150 ## 5 8 140 ## 6 8 198 We can create a scatter plot between these two variables to see their relationship. This also shows the reason why want to subset data frame. plot(Auto[,c(2,4)]) The scatter plot clearly demonstrates that a higher horsepower is assoicated with a larger number of cylinders. We can also subset the dataset by variable name. We need to use $ for subsetting one variable with its variable name. # Auto$mpg selects the variable mpg # type hist[Auto$mpg] to get its distribution hist(Auto$acceleration) # select multiple columns by name. head( Auto[,c(&quot;horsepower&quot;,&quot;mpg&quot;,&quot;weight&quot;)] ) ## horsepower mpg weight ## 1 130 18 3504 ## 2 165 15 3693 ## 3 150 18 3436 ## 4 150 16 3433 ## 5 140 17 3449 ## 6 198 15 4341 Filter rows by condition: # select all rows with mpg less equal to 12 Auto[Auto$mpg&lt;=12,] ## mpg cylinders displacement horsepower weight acceleration year rating ## 26 10 8 360 215 4615 14.0 70 2 ## 27 10 8 307 200 4376 15.0 70 2 ## 28 11 8 318 210 4382 13.5 70 2 ## 29 9 8 304 193 4732 18.5 70 2 ## 42 12 8 383 180 4955 11.5 71 1 ## 67 11 8 429 208 4633 11.0 72 2 ## 69 12 8 350 160 4456 13.5 72 1 ## 90 12 8 429 198 4952 11.5 73 2 ## 95 12 8 455 225 4951 11.0 73 1 ## 103 11 8 400 150 4997 14.0 73 1 ## 104 12 8 400 167 4906 12.5 73 2 ## 106 12 8 350 180 4499 12.5 73 2 ## 124 11 8 350 180 3664 11.0 73 2 ## origin name ## 26 US ford f250 ## 27 US chevy c20 ## 28 US dodge d200 ## 29 US hi 1200d ## 42 US dodge monaco (sw) ## 67 US mercury marquis ## 69 US oldsmobile delta 88 royale ## 90 US mercury marquis brougham ## 95 US buick electra 225 custom ## 103 US chevrolet impala ## 104 US ford country ## 106 US oldsmobile vista cruiser ## 124 US oldsmobile omega # select all rows with mpg less equal to 12 and greater equal to 11 Auto[Auto$mpg&gt;=11 &amp; Auto$mpg&lt;=12,] ## mpg cylinders displacement horsepower weight acceleration year rating ## 28 11 8 318 210 4382 13.5 70 2 ## 42 12 8 383 180 4955 11.5 71 1 ## 67 11 8 429 208 4633 11.0 72 2 ## 69 12 8 350 160 4456 13.5 72 1 ## 90 12 8 429 198 4952 11.5 73 2 ## 95 12 8 455 225 4951 11.0 73 1 ## 103 11 8 400 150 4997 14.0 73 1 ## 104 12 8 400 167 4906 12.5 73 2 ## 106 12 8 350 180 4499 12.5 73 2 ## 124 11 8 350 180 3664 11.0 73 2 ## origin name ## 28 US dodge d200 ## 42 US dodge monaco (sw) ## 67 US mercury marquis ## 69 US oldsmobile delta 88 royale ## 90 US mercury marquis brougham ## 95 US buick electra 225 custom ## 103 US chevrolet impala ## 104 US ford country ## 106 US oldsmobile vista cruiser ## 124 US oldsmobile omega We can perform operation on existing variable and create new variables and add these new variable into the data frame. E.g., The following code creates a new variable called horsepowerpercylinder, which is horsepower divided by # of cylinders, # and adds to the data frame. Auto$horsepowerpercylinder=Auto$horsepower/Auto$cylinders str(Auto) ## &#39;data.frame&#39;: 392 obs. of 11 variables: ## $ mpg : num 18 15 18 16 17 15 14 14 14 15 ... ## $ cylinders : int 8 8 8 8 8 8 8 8 8 8 ... ## $ displacement : num 307 350 318 304 302 429 454 440 455 390 ... ## $ horsepower : int 130 165 150 150 140 198 220 215 225 190 ... ## $ weight : int 3504 3693 3436 3433 3449 4341 4354 4312 4425 3850 ... ## $ acceleration : num 12 11.5 11 12 10.5 10 9 8.5 10 8.5 ... ## $ year : int 70 70 70 70 70 70 70 70 70 70 ... ## $ rating : int 3 1 3 2 1 2 1 2 1 1 ... ## $ origin : chr &quot;US&quot; &quot;US&quot; &quot;US&quot; &quot;US&quot; ... ## $ name : chr &quot;chevrolet chevelle malibu&quot; &quot;buick skylark 320&quot; &quot;plymouth satellite&quot; &quot;amc rebel sst&quot; ... ## $ horsepowerpercylinder: num 16.2 20.6 18.8 18.8 17.5 ... We can also rename variables using the names() function. # eamine the existing name of the Auto datafile. names(Auto) ## [1] &quot;mpg&quot; &quot;cylinders&quot; &quot;displacement&quot; ## [4] &quot;horsepower&quot; &quot;weight&quot; &quot;acceleration&quot; ## [7] &quot;year&quot; &quot;rating&quot; &quot;origin&quot; ## [10] &quot;name&quot; &quot;horsepowerpercylinder&quot; # change the 11th variable name to power_per_cylinder names(Auto)[11]=&quot;power_per_cylinder&quot; str(Auto) ## &#39;data.frame&#39;: 392 obs. of 11 variables: ## $ mpg : num 18 15 18 16 17 15 14 14 14 15 ... ## $ cylinders : int 8 8 8 8 8 8 8 8 8 8 ... ## $ displacement : num 307 350 318 304 302 429 454 440 455 390 ... ## $ horsepower : int 130 165 150 150 140 198 220 215 225 190 ... ## $ weight : int 3504 3693 3436 3433 3449 4341 4354 4312 4425 3850 ... ## $ acceleration : num 12 11.5 11 12 10.5 10 9 8.5 10 8.5 ... ## $ year : int 70 70 70 70 70 70 70 70 70 70 ... ## $ rating : int 3 1 3 2 1 2 1 2 1 1 ... ## $ origin : chr &quot;US&quot; &quot;US&quot; &quot;US&quot; &quot;US&quot; ... ## $ name : chr &quot;chevrolet chevelle malibu&quot; &quot;buick skylark 320&quot; &quot;plymouth satellite&quot; &quot;amc rebel sst&quot; ... ## $ power_per_cylinder: num 16.2 20.6 18.8 18.8 17.5 ... To delete a variable from data frames: # Delete the variable power_per_cylinder Auto=Auto[,-c(11)] str(Auto) ## &#39;data.frame&#39;: 392 obs. of 10 variables: ## $ mpg : num 18 15 18 16 17 15 14 14 14 15 ... ## $ cylinders : int 8 8 8 8 8 8 8 8 8 8 ... ## $ displacement: num 307 350 318 304 302 429 454 440 455 390 ... ## $ horsepower : int 130 165 150 150 140 198 220 215 225 190 ... ## $ weight : int 3504 3693 3436 3433 3449 4341 4354 4312 4425 3850 ... ## $ acceleration: num 12 11.5 11 12 10.5 10 9 8.5 10 8.5 ... ## $ year : int 70 70 70 70 70 70 70 70 70 70 ... ## $ rating : int 3 1 3 2 1 2 1 2 1 1 ... ## $ origin : chr &quot;US&quot; &quot;US&quot; &quot;US&quot; &quot;US&quot; ... ## $ name : chr &quot;chevrolet chevelle malibu&quot; &quot;buick skylark 320&quot; &quot;plymouth satellite&quot; &quot;amc rebel sst&quot; ... To access the mpg in Auto data frame, we must use $ (e.g., Auto$mpg). If you simply use mpg, R would not know which data frame to look for mpg. But this causes the code too long and hard to read. We can use with() function to avoid that. E.g., plot the scatter plot between weight and mpg with(Auto, plot(weight, mpg) ) The general format of with() function is to: with(DATA FRAME, CODE USING THE DATA FRAME) 4.5 Write a data frame to your computer We can use write.csv() to write the data frame to your local computer. write.csv(Auto,&quot;data/Auto2.csv&quot;, row.names =FALSE) Note, row.names = TRUE will generate an automatic ID (i.e., 1,2,3, ) for each rows. 4.6 Summary While all elements in vector and matrix must be the same type, data.frame allows different columns (i.e., variable) to be different types. use Base R for creating plots. subsetting data.frame using index and variable names. Use read.csv() to read csv file into R as data.frame; learn to subset data.frame. Use write.csv() to write data.frame from R to your local computer. "],["functions.html", "Chapter 5 Functions 5.1 Get the Help Document of A Function 5.2 Call build-in functions in R 5.3 Write Your Own Functions 5.4 Flexible Function 5.5 Excercise 1 5.6 The apply() function family 5.7 Scoping Rule in R 5.8 Excercise", " Chapter 5 Functions Functions are the building blocks in R. There are two ways to pass arguments to a function: by argument names and by position. You will learn to call function through these two ways. In addition, you also will Learn to examine the help document of each function by using ?function_name. Understand the default value of arguments. Open the black box of functions by learning to write your own functions. Understand the scoping rule of R. 5.1 Get the Help Document of A Function You cannot memorize all functions and their usage. We rely on the help documents of the function. Take seq() function as an example. This function can generate a sequence of number. We can type ?seq to get the help document of the function ?seq 5.2 Call build-in functions in R The help document of seq() shows the augments of the function is: seq(from = 1, to = 1, by , length , ) Here from, to, by, length are the argument of the functions. Once we pass value to these arguments, the function will then process these arguments according to its code inside the function. E.g., we want to generate a sequence of even number from 2 to 12. by argument name. seq(from=2,to=12, by=2) ## [1] 2 4 6 8 10 12 by position seq(2,12, 2) ## [1] 2 4 6 8 10 12 5.3 Write Your Own Functions The general format for defining function is as follow: function_name=function(argument1,arugment2, ...){ # Code to Process the arguments return(results) } E.g., our first task is to write a function to calculate the sum square of two numbers. myfun1=function(x1,x2){ return(x1^2+x2^2) } By default, the result from the last line of the function will be the returned result. So we can change the last line as: \\(x_1^2+x_2^2\\). Once we define the function, it is ready to be used just as other functions built-in R. call function by argument name myfun1(x2=2,x1=1) ## [1] 5 call function by position myfun1(1,2) ## [1] 5 5.4 Flexible Function You may notice that some functions have an argument of . This is called flexible function. Lets take a look at an example: We will define a plot function to make a scatter plot between two variable, and add a linear fitted linear to the plot. abplot=function(x,y,...){ plot(x,y,... ) # create a scatter plot abline(lm(y~x)) # add a fitted line } Essentially, anything you passed in the position of  will be passed to the plot() function. We can now call abplot() function with additional arguments as below: Auto=read.csv(&quot;data/Auto.csv&quot;) abplot(Auto$weight, Auto$mpg, type=&quot;p&quot;, xlab=&quot;weight&quot;, ylab=&quot;mpg&quot;,col=&quot;red&quot;) 5.5 Excercise 1 Write a function to calculate the descriptive statistics of an array of numbers (i.e., mean, standard deviation and skewness). Skewness is a measure of symmetry, or more precisely, the lack of symmetry. Below is the formula for computing skewness of a variable. \\[skewness =\\frac{\\sum_{i=1}^n(x_i  \\bar x)^3}{n*\\sigma^3}\\] A variable with skewness close to 0 tend to be symmetry; A variable with negative skewness tend to left skewed; A variable with positive skewness tend to right. mystat=function(x){ avg=mean(x) sd=sd(x) skewness=mean((x-avg)^3)/sd^3 return(c(avg, sd, skewness)) # return mean and std dev as a vector } # acceleration is not as skewed mystat(Auto$acceleration) ## [1] 15.5413265 2.7588641 0.2893592 # horsepower is right skewed mystat(Auto$horsepower) ## [1] 104.469388 38.491160 1.079019 5.6 The apply() function family The apply() function family is very useful for data analysis. The function looks like below: apply(X, MARGIN, FUN, ), where X is 2-dimensional data array, e.g., matrix or a data.frame; MARGIN is a variable defining how the function is applied: when MARGIN=1, it applies over rows, whereas with MARGIN=2, it works over columns FUN, which is the function that you want to apply to the data. apply(Auto[c(&quot;mpg&quot;,&quot;weight&quot;,&quot;horsepower&quot;)], 2, mystat) In addition, lapply() and sapply() are the two variants of apply(). lapply() and sapply() both work over column and return results in different format. # apply function on the column and return results as list lapply(Auto[c(&quot;mpg&quot;,&quot;weight&quot;,&quot;horsepower&quot;)], mystat) ## $mpg ## [1] 23.4459184 7.8050075 0.4536001 ## ## $weight ## [1] 2977.584184 849.402560 0.515616 ## ## $horsepower ## [1] 104.469388 38.491160 1.079019 # apply function on column and return a simplified results sapply(Auto[c(&quot;mpg&quot;,&quot;weight&quot;,&quot;horsepower&quot;)], mystat) ## mpg weight horsepower ## [1,] 23.4459184 2977.584184 104.469388 ## [2,] 7.8050075 849.402560 38.491160 ## [3,] 0.4536001 0.515616 1.079019 5.7 Scoping Rule in R Scoping Rule determines where R should search the value of free variable inside a function. Free variables inside a function is the variables that is neither defined in a function nor the functions argument. Lets look at an example. power=2 myfun2=function(x){ x^power } myfun2(5) ## [1] 25 In the above code, power is a free variable. A good practice is to avoid free variables. In other word, we should define variables needed by a function either through arguments or define locally within the function. For example, we can revise the above function as below: power=2 myfun2=function(x){ power=3 # define power inside the function x^power } # guess, what is the value of myfun2(2) myfun2(2) ## [1] 8 # guess, what is the value of power power ## [1] 2 The scoping rule in R determines that what is the value of power when we call myfun2(2). In R, the program will first search inside the function whether power is defined. If yes, then use the value defined inside the function. Otherwise, the program examine whether power is defined outside the function. Changing the value inside the function will not change the variable outside the function. 5.8 Excercise Support you are working at a bank provides mortgage loan. One important task is to calculate the monthly mortgage payment for any given loan. You can use the following equation to calculate the monthly mortgage payment: \\[M = P ( i(1 + i)^n ) / ( (1 + i)^n - 1)\\] where P = principal loan amount i = annual_interest_rate/12, i.e., i is the monthly interest rate, which is the annual interest rate divided by 12 n = number of months required to repay the loan In this exercise, your goal is define a function for calculating monthly mortgage payment. The function takes three arguments: P(principal), annual_rate, year_repay. The default year_repay is 30, which is the most common mortgage term. "],["flow-control.html", "Chapter 6 Flow Control 6.1 ifelse Statement 6.2 ifelse ifelse Statement 6.3 Exercise 6.4 for loop 6.5 Break Your Loops With break 6.6 Jump to the next cycly with next 6.7 Exercise 6.8 While Loop", " Chapter 6 Flow Control You have written over 500 lines of code. This is a great achievement. All the code we write so far runs from up to the bottom in a linear fashion. Today, we will learn the if, for, and while statements to control the flow of your code. 6.1 ifelse Statement To be or not to be, this is a problem? When solving real problems using computer codes, we will inevitably have to branch our code in different directions based on some criteria. The simplest format for IF-statement in R is: if (logical_expression) { # statement will only be executed if logical_expression is true statement } We can also have else statement as below: if (logical_expression) { # statement1 will be executed if logical_expression is true statement1 } else { # statement2 will be executed if logical_expression is false statement2 } In the above case, statement1 will be excuted if the logical_expression is true; otherwise, statement2 will be executed. Take one example, we will create a door with password. The door will open if you input the correct password, but the door will be closed if you input the incorrect password. pw=&quot;2497&quot; pw_entered=readline(&quot;Please enter the password: &quot;) if (pw_entered==pw){ print(&quot;The door is opened. Welcome!&quot;) } else { print(&quot;Password wrong. Door closed!&quot;) } In this case, the logical expression evaluates whether pw_entered==pw is true or not. If true, then the program proceeds to print(The door is opened. Welcome!); If not true, then the program proceeds to print(Password wrong. Door closed!). 6.2 ifelse ifelse Statement The ifelse statement is great to program the binary outcome (e.g., correct password or incorrect password). However, sometime we need to deal with more than two outcomes. In this case, we need to use the ifelse ifelse statement: if ( logical_expression1) { statement1 } else if ( logical_expression2) { statement2 } else { statement3 } logical_expression1 and logical_expression2 are a set of mutually exclusive criteria; only one statement will be executed depending on which logical_expression is true. You can have more else as needed. 6.3 Exercise In data analysis, we often want to bin a continuous variable into categorical of low, median, high or even more category. For example, we want to classify Auto as low, median, high gas efficiency based on mpg: if mpg&lt;22, the efficiency is low; if 26&gt;mpg&gt;=22, then the efficiency is median; if mpg&gt;=26, then the efficiency is high. mpg=23 if (mpg&lt;22) { efficiency=&quot;low&quot; } else if (mpg&lt;26) { efficiency=&quot;median&quot; } else{ efficiency=&quot;high&quot; } efficiency ## [1] &quot;median&quot; Note that we did not need to write mpg&gt;=22 &amp; mpg&lt;26 in the second criteria since the second criteria will only be evaluated when mpg&gt;=22. 6.4 for loop In computer programming, we sometime want to do things repetitively. For example, there are 10 data files, each corresponding to a specific year. Want to read all these 10 files into R; or we will visit 100 different websites to scrape the data from web. Loop allows the program to go back to previous code and do things repetitively. In R programming, a for-loop is used to iterate over a vector. The syntax of for loop is for (val in sequence){ statement } Here, sequence is a vector and val takes on each of its value during the loop. val is also called iterator because it will iterate every elements in sequence. In each iteration, statement is evaluated. Lets look at one simple example. For example, print 1 to 10 on the screen. This is a repetitive task, i.e., printing a number on screen for 10 times. We can use for loop to achieve this. for (i in 1:10){ print(i) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 In this example, 1:10 generates a vector from 1 to 100. i will iterate every value from 1 to 10 and be printed on the screen. The sequence can also be a character vector. For example, the following code will print every elements of the character vector on the screen. students=c(&quot;John&quot;,&quot;Lily&quot;,&quot;Leon&quot;,&quot;Brandon&quot;) for (i in students){ print(i) } ## [1] &quot;John&quot; ## [1] &quot;Lily&quot; ## [1] &quot;Leon&quot; ## [1] &quot;Brandon&quot; In the above code, i will iterate over the students vector; and print(i) will be excuted for 4 times, with i taking the value of John, Lily, Leon, Brandon. For example, we want to calculate the sum square from 1 to 100. sum=0 # initize the sum as 0 # we will add the square of a number (1-100) to sum for (i in 1:100){ sum=sum+i^2 } sum ## [1] 338350 In this example, i will iterate every value from 1 to 100; and the statement will thus be excuted for 100 times, with i taking the value from 1 to 100. 6.5 Break Your Loops With break As seen in above examples, for-loop requires the program to iterate every element in the vector. However, you can break your loop with break. When the R encounters a break, it will exit the loop immediately. For example, in the printing students name example, we will exit the loop if the iterator takes the value Leon and print Leon is not student. students=c(&quot;John&quot;,&quot;Lily&quot;,&quot;Leon&quot;,&quot;Brandon&quot;) for (i in students){ if (i==&quot;Leon&quot;){ print(&quot;Leon is not student.&quot;) break } else{ print(i) } } ## [1] &quot;John&quot; ## [1] &quot;Lily&quot; ## [1] &quot;Leon is not student.&quot; 6.6 Jump to the next cycly with next The above code shows that we can use break to end the loop if the iterator meets certain criteria. However, in some cases, we do not want to end the loop completely, but to skip the particular iteration. We can use next to discontinue a particular iteration and jumps to the next cycle. students=c(&quot;John&quot;,&quot;Lily&quot;,&quot;Leon&quot;,&quot;Brandon&quot;) for (i in students){ if (i==&quot;Leon&quot;){ print(&quot;Leon is not student!&quot;) next } else{ print(i) } } ## [1] &quot;John&quot; ## [1] &quot;Lily&quot; ## [1] &quot;Leon is not student!&quot; ## [1] &quot;Brandon&quot; 6.7 Exercise Lets revisit the door password problem. In this exercise, we want to design the password in such way that you have three chances to input the passwords. If you enter the password correctly within the three times, the door will open; you have the opportunity to re-enter the password before you running out of the three chances; if you did not enter the correct password within the three trials, the door will be closed. This is a repetitive task because you are asked to enter the password for three times. We can thus use for-loop for this purpose. Verison 1: pw=&quot;2497&quot; for (i in 1:3){ pw_entered=readline(&quot;Please enter the password: &quot;) if (pw_entered==pw){ print(&quot;The door is opened. Welcome!&quot;) break } else { print(&quot;Password wrong. Please re-enter the password: &quot;) } } Verison 2: When i=3, the code should show that the door is locked due to too many failed trials, rather than asking for re-enter the password. pw=&quot;2497&quot; for (i in 1:3){ pw_entered=readline(&quot;Please enter the password: &quot;) if (pw_entered==pw){ print(&quot;The door is opened. Welcome!&quot;) break } else if(i!=3){ print(&quot;Password wrong. Please re-enter the password: &quot;) } else { print(&quot;Password wrong. Door closed.&quot;) } } 6.8 While Loop In R programming, while loops are used to loop until a specific condition is met. The while loop is also used for repetitive task. The syntax for while-loop is as below: while (test_expression) { statement } Here, test_expression is evaluated and the body of the loop is entered if the result is TRUE. Lets look at how to calculate the sum square from 1 to 100 using while loop. sum=0 # initize the sum as 0 i=1 # initize the iterator # we will add the square of a number (1-100) to sum while (i&lt;=100){ sum=sum+i^2 i=i+1 } sum ## [1] 338350 Lets revist the password door exercise. You will have 3 chances to enter the correct password to open the door. This time, implement this with while-loop. pw=&quot;2497&quot; i=1 # initialize the iterator while (i &lt;= 3){ pw_entered=readline(&quot;Please enter the password: &quot;) if (pw_entered==pw){ print(&quot;The door is opened. Welcome!&quot;) break } else if(i!=3){ print(&quot;Password wrong. Please re-enter the password: &quot;) } else { print(&quot;Password wrong. Door closed.&quot;) } i=i+1 # increase the iterator by 1 at the end } As seen, it is much easily to use for-loop for iterating over a fixed sequence because we do not need to manually update the iterator. Typically, we use while-loop if we do not how many iteration will be conducted; and use for-loop if we know how many iteration to be conducted. Also, break/next work similarly with while-loop to exit the while-loop or to jump to the next iteration within the while-loop, respectively. "],["r-markdown-for-documentation.html", "Chapter 7 R markdown for documentation 7.1 rock, paper, scissors 7.2 verison 1: 7.3 verison 2 7.4 Version 3 7.5 verision 4 7.6 version 5", " Chapter 7 R markdown for documentation We have been writing code in Rscript and all the result of your code is printed at the console. From now on, we will learn to use a powerful interactive notebook interface to write code and display results. In addition, you can also use multiple languages including R, Python, and SQL in R-markdown. We will later introduce how to insert python code in r-markdown. Next, we will write code in r-markdown to implement some small applications. In particular, we have learned the statement of ifelse if for branching; the for/while-loop for repetitive task. Today, we will use these statements to write the first computer game in R. 7.1 rock, paper, scissors Lets write a program to play the rock, paper, scissors with the computer. At each round, the computer and you will choose one from rock, paper, scissors. Then you compare the computers and your choice to determine 1) you won 2) computer won 3) tie. Since there are three different outcomes, we need ifelse ifelse statement. 7.2 verison 1: you=&quot;rock&quot; computer=&quot;paper&quot; if (computer==you){ print(&quot;this is a tie.&quot;) } else if((computer==&quot;rock&quot; &amp; you==&quot;paper&quot;)|(computer==&quot;paper&quot; &amp; you==&quot;scissors&quot;)|(computer==&quot;scissors&quot; &amp; you==&quot;rock&quot;) ){ print(&quot;You won!&quot;) } else{ print(&quot;Oops, computer won!&quot;) } ## [1] &quot;Oops, computer won!&quot; While version 1 is a boring game because you have already know the outcome of the game. In order not to have the pre-determined outcome, we need to let you and computer randomly choose from rock, paper, scissors. There is a convenient function in R for random sampling: sample(vector, n, replace=TRUE) samples n elements from vector with replacement. With replacement means that the sampled element is put back for the next sampling. E.g., sample(c(&quot;rock&quot;,&quot;paper&quot;,&quot;scissors&quot;), 4, replace=TRUE) ## [1] &quot;paper&quot; &quot;paper&quot; &quot;paper&quot; &quot;paper&quot; 7.3 verison 2 With the sample() function, we can improve the program as below: #you=sample(c(&quot;rock&quot;,&quot;paper&quot;,&quot;scissors&quot;), 1, replace=TRUE) you=readline(&quot;please enter your action: rock, paper, scissors &gt; &quot;) computer=sample(c(&quot;rock&quot;,&quot;paper&quot;,&quot;scissors&quot;), 1, replace=TRUE) print(paste(&quot;your action is&quot;, you)) print(paste(&quot;computer action is&quot;, computer)) if (computer==you){ print(&quot;this is a tie.&quot;) } else if((computer==&quot;rock&quot; &amp; you==&quot;paper&quot;)|(computer==&quot;paper&quot; &amp; you==&quot;scissors&quot;)|(computer==&quot;scissors&quot; &amp; you==&quot;rock&quot;) ){ print(&quot;You won!&quot;) } else{ print(&quot;Oops, computer won!&quot;) } 7.4 Version 3 Lets revisit the rock, paper, scissors game. This time, you and computer will play rock, paper, scissors for three rounds. Whoever won more rounds will be the winner. Playing 3 rounds is a repetitive task, we can use for-loop. Since the game will be playing multiple rounds, we will need to implement a score board to keep track of the score at each round (think of the score board in a basketball game). you_score=0 computer_score=0 for (i in 1:3){ #you=sample(c(&quot;rock&quot;,&quot;paper&quot;,&quot;scissors&quot;), 1, replace=TRUE) you=readline(&quot;please enter your action: rock, paper, scissors &gt; &quot;) computer=sample(c(&quot;rock&quot;,&quot;paper&quot;,&quot;scissors&quot;), 1, replace=TRUE) print(paste(&quot;your action is&quot;, you)) print(paste(&quot;computer action is&quot;, computer)) if (computer==you){ print(&quot;this is a tied round.&quot;) } else if((computer==&quot;rock&quot; &amp; you==&quot;paper&quot;)|(computer==&quot;paper&quot; &amp; you==&quot;scissors&quot;)|(computer==&quot;scissors&quot; &amp; you==&quot;rock&quot;) ){ print(&quot;You won in this round!&quot;) you_score=you_score+1 } else{ print(&quot;Oops, computer won in this round!&quot;) computer_score=computer_score+1 } } # determine who won finally print(&quot;The final score is: &quot;) print(paste(&quot;you: &quot;, you_score, &quot; V.S. &quot;, &quot;computer: &quot;, computer_score, sep=&quot;&quot;)) if (you_score&gt;computer_score){ print(&quot;You won!&quot;) } else if (you_score==computer_score){ print(&quot;tie game&quot;) } else { print(&quot;Computer won!&quot;) } 7.5 verision 4 Define a rps function for re-use: # determine the winner based on action rps=function(you, computer){ computer_score=0 you_score=0 print(paste(&quot;your action is&quot;, you)) print(paste(&quot;computer action is&quot;, computer)) if (computer==you){ print(&quot;this is a tied round.&quot;) } else if((computer==&quot;rock&quot; &amp; you==&quot;paper&quot;)|(computer==&quot;paper&quot; &amp; you==&quot;scissors&quot;)|(computer==&quot;scissors&quot; &amp; you==&quot;rock&quot;) ){ print(&quot;You won in this round!&quot;) you_score=you_score+1 } else{ print(&quot;Oops, computer won in this round!&quot;) computer_score=computer_score+1 } return(c(computer_score,you_score)) } # the function to print the score winner=function(computer_score,you_score){ print(&quot;The final score is: &quot;) print(paste(&quot;you: &quot;, you_score, &quot; V.S. &quot;, &quot;computer: &quot;, computer_score, sep=&quot;&quot;)) if (you_score&gt;computer_score){ print(&quot;You won!&quot;) } else if (you_score==computer_score){ print(&quot;tie game&quot;) } else { print(&quot;Computer won!&quot;) } } #you=sample(c(&quot;rock&quot;,&quot;paper&quot;,&quot;scissors&quot;), 1, replace=TRUE) you=readline(&quot;please enter your action: rock, paper, scissors &gt; &quot;) computer=sample(c(&quot;rock&quot;,&quot;paper&quot;,&quot;scissors&quot;), 1, replace=TRUE) score=rps(you,computer) winner(score[1],score[2]) 7.6 version 5 Lets revisit the rock, paper, scissors game. After each round, the program will ask you whether you want to continue to play another round. The program ends if you enter no; otherwise, the program will continue to the next round. This is also an iterative task, but we do not know in advance how many iteration will be. Thus, we can use while-loop. continue=&quot;yes&quot; # the logical expression in the while loop total_score=c(0,0) while (continue!=&quot;no&quot;){ you=readline(&quot;please enter your action: rock, paper, scissors &gt; &quot;) computer=sample(c(&quot;rock&quot;,&quot;paper&quot;,&quot;scissors&quot;), 1, replace=TRUE) score=rps(you,computer) total_score=total_score+score continue=readline(&quot;Do you want to play another round (yes/no): &quot;) } winner(total_score[1],total_score[2]) Congratulation! You have just created your first computer game in R! "],["use-data-table-package-for-big-data.html", "Chapter 8 Use data.table Package for Big Data 8.1 Install R Packages 8.2 fread(): Read csv file into R as data.table 8.3 Quick summary of the data 8.4 Data Manipulation with data.table 8.5 Select Columns 8.6 Calcuation by Group 8.7 Summary", " Chapter 8 Use data.table Package for Big Data Packages are the fundamental units of reproducible R code. They include reusable R functions, the documentation that describes how to use them, and sample data. There are currently 120,000 packages in R, which empower you to do all kinds of data analysis. This huge variety of packages is one of the reasons that R is so successful: the chances are that someone has already solved a problem that youre working on, and you can benefit from their work by downloading their package. The data.table package in R provides an enhanced version of data.frame that allows you to do blazing fast data manipulations. The data.table package is being used in different fields such as finance and genomics which encounter large data sets (for example, 1GB to 100GB). Why we are interested in learning data.table package among all these packages? The data.table package in a sense helped to save R. At one point a few years ago, there were major concerns that R could not handle Big Data, with calls from some in favor of Python instead. The data.table package showed that R could do quite well in large datasets. This really aided in Rs being adopted by various large companies  Norm Matloff, Prof. of Computer Science, UC Davis 8.1 Install R Packages There are over 120,000 packages in R. As you can imagine, it is not wise to install every package in R, which will take enormous computer storage space. In fact, when installing R, we will install the most essential packages, which are known as base R. For example, the functions learned so far are all from base R (e.g., data.frame, plot, loop, if ). Base R can perform the basic functions. But we can enhance the power of R by installing packages. We can install R packages as needed through the following syntax: install.packages(&quot;package_name&quot;) # download and install the package library(package_name) # load the package into memory The packages are typically saved at the Comprehensive R Archive Network (CRAN); we do not need to worry about where the package is saved exactly on the Internet; R will take care of that automatically. Lets install the data.table package by running following code: install.packages(&quot;data.table&quot;) As you will see, downloading and installing the package takes times, especially when the package is big. Thus, I will run this code just once to install the package. Every time when you reopen your R project, you just need to load the package into your memory through the following code: library(&quot;data.table&quot;) Now that you have loaded the package into the computer memory, you can use all the powerful functions from the package. On the right bottom corner of R-studio, you should be able to examine all the packages that are installed. The packages that are checked are the ones loaded into the memory. As said, data.table is an enhanced venison of data.frame. Thus, recall what we did in the lecture about data.frame. We will learn how to read data file into R as data.table. how to manipulate data.table. We will use the flights dataset for the purpose of illustration. The flights dataset contains flights information for all the flights departing from New York City airports in 2013. This dataset is from from the Bureau of Transporation Statistics. 8.2 fread(): Read csv file into R as data.table Remember, in read.csv() reads a dataset into R as data.frame. In comparison, fread() from data.table package will read a csv file into R as a data.table. # type ?fread to check its help document ?fread Now, lets read flights.csv into R using fread() function in data.table package. flights=fread(&quot;data/flights.csv&quot;) The flights.csv is 31.9MB, with 336,776 observation and 19 variables. This is not a small dataset. But as you can feel, fread() is blazing fast. We can use the class() function to examine the type of the data.table (flights) we just created: class(flights) ## [1] &quot;data.table&quot; &quot;data.frame&quot; As seen, flights belongs to both data.table and data.frame. As mentioned, this is because data.table is an extension (enhancement of data.frame). Therefore, all functions works on data.frame all works on data.table. Now, lets compare the performance of data.table and data.frame in terms reading data into R. Performance benchmark between different programs is very common to determine which one is better. system.time( read.csv(&quot;data/flights.csv&quot;) ) ## user system elapsed ## 1.34 0.09 1.44 system.time( fread(&quot;data/flights.csv&quot;) ) ## user system elapsed ## 0.10 0.00 0.06 As seen, read.csv() spends 1.42 seconds to read the data; while fread() spends 0.06 seconds to read the data. fread() is 23 times faster (this will be different depending on the machine you used). The advantage will be even prominent if we are dealing with even big file. 8.2.1 Convert data.frame into data.table You can convert an existing data.frame into a data.table using data.table() function. tmp=read.csv(&quot;data/flights.csv&quot;) class(tmp) ## [1] &quot;data.frame&quot; tmp=data.table(tmp) class(tmp) ## [1] &quot;data.table&quot; &quot;data.frame&quot; 8.3 Quick summary of the data In the excel file, we can easily see the data in the tabular format. With R-stuido, you can click flights on the top right corner to see the data. But more commonly, we will examine the data through a few quick summary: Use head()/tail() to show the first/last 6 rows of the data. head(flights) ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## 1: 2013 1 1 517 515 2 830 819 ## 2: 2013 1 1 533 529 4 850 830 ## 3: 2013 1 1 542 540 2 923 850 ## 4: 2013 1 1 544 545 -1 1004 1022 ## 5: 2013 1 1 554 600 -6 812 837 ## 6: 2013 1 1 554 558 -4 740 728 ## arr_delay carrier flight tailnum origin dest air_time distance hour minute ## 1: 11 UA 1545 N14228 EWR IAH 227 1400 5 15 ## 2: 20 UA 1714 N24211 LGA IAH 227 1416 5 29 ## 3: 33 AA 1141 N619AA JFK MIA 160 1089 5 40 ## 4: -18 B6 725 N804JB JFK BQN 183 1576 5 45 ## 5: -25 DL 461 N668DN LGA ATL 116 762 6 0 ## 6: 12 UA 1696 N39463 EWR ORD 150 719 5 58 ## time_hour ## 1: 2013-01-01 05:00:00 ## 2: 2013-01-01 05:00:00 ## 3: 2013-01-01 05:00:00 ## 4: 2013-01-01 05:00:00 ## 5: 2013-01-01 06:00:00 ## 6: 2013-01-01 05:00:00 tail(flights) ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## 1: 2013 9 30 NA 1842 NA NA 2019 ## 2: 2013 9 30 NA 1455 NA NA 1634 ## 3: 2013 9 30 NA 2200 NA NA 2312 ## 4: 2013 9 30 NA 1210 NA NA 1330 ## 5: 2013 9 30 NA 1159 NA NA 1344 ## 6: 2013 9 30 NA 840 NA NA 1020 ## arr_delay carrier flight tailnum origin dest air_time distance hour minute ## 1: NA EV 5274 N740EV LGA BNA NA 764 18 42 ## 2: NA 9E 3393 &lt;NA&gt; JFK DCA NA 213 14 55 ## 3: NA 9E 3525 &lt;NA&gt; LGA SYR NA 198 22 0 ## 4: NA MQ 3461 N535MQ LGA BNA NA 764 12 10 ## 5: NA MQ 3572 N511MQ LGA CLE NA 419 11 59 ## 6: NA MQ 3531 N839MQ LGA RDU NA 431 8 40 ## time_hour ## 1: 2013-09-30 18:00:00 ## 2: 2013-09-30 14:00:00 ## 3: 2013-09-30 22:00:00 ## 4: 2013-09-30 12:00:00 ## 5: 2013-09-30 11:00:00 ## 6: 2013-09-30 08:00:00 Use summary() to get summary statistics for each variable. summary(flights) ## year month day dep_time sched_dep_time ## Min. :2013 Min. : 1.000 Min. : 1.00 Min. : 1 Min. : 106 ## 1st Qu.:2013 1st Qu.: 4.000 1st Qu.: 8.00 1st Qu.: 907 1st Qu.: 906 ## Median :2013 Median : 7.000 Median :16.00 Median :1401 Median :1359 ## Mean :2013 Mean : 6.549 Mean :15.71 Mean :1349 Mean :1344 ## 3rd Qu.:2013 3rd Qu.:10.000 3rd Qu.:23.00 3rd Qu.:1744 3rd Qu.:1729 ## Max. :2013 Max. :12.000 Max. :31.00 Max. :2400 Max. :2359 ## NA&#39;s :8255 ## dep_delay arr_time sched_arr_time arr_delay ## Min. : -43.00 Min. : 1 Min. : 1 Min. : -86.000 ## 1st Qu.: -5.00 1st Qu.:1104 1st Qu.:1124 1st Qu.: -17.000 ## Median : -2.00 Median :1535 Median :1556 Median : -5.000 ## Mean : 12.64 Mean :1502 Mean :1536 Mean : 6.895 ## 3rd Qu.: 11.00 3rd Qu.:1940 3rd Qu.:1945 3rd Qu.: 14.000 ## Max. :1301.00 Max. :2400 Max. :2359 Max. :1272.000 ## NA&#39;s :8255 NA&#39;s :8713 NA&#39;s :9430 ## carrier flight tailnum origin ## Length:336776 Min. : 1 Length:336776 Length:336776 ## Class :character 1st Qu.: 553 Class :character Class :character ## Mode :character Median :1496 Mode :character Mode :character ## Mean :1972 ## 3rd Qu.:3465 ## Max. :8500 ## ## dest air_time distance hour ## Length:336776 Min. : 20.0 Min. : 17 Min. : 1.00 ## Class :character 1st Qu.: 82.0 1st Qu.: 502 1st Qu.: 9.00 ## Mode :character Median :129.0 Median : 872 Median :13.00 ## Mean :150.7 Mean :1040 Mean :13.18 ## 3rd Qu.:192.0 3rd Qu.:1389 3rd Qu.:17.00 ## Max. :695.0 Max. :4983 Max. :23.00 ## NA&#39;s :9430 ## minute time_hour ## Min. : 0.00 Length:336776 ## 1st Qu.: 8.00 Class :character ## Median :29.00 Mode :character ## Mean :26.23 ## 3rd Qu.:44.00 ## Max. :59.00 ## str() is THE function for examining structure of a dataset. str(flights) ## Classes &#39;data.table&#39; and &#39;data.frame&#39;: 336776 obs. of 19 variables: ## $ year : int 2013 2013 2013 2013 2013 2013 2013 2013 2013 2013 ... ## $ month : int 1 1 1 1 1 1 1 1 1 1 ... ## $ day : int 1 1 1 1 1 1 1 1 1 1 ... ## $ dep_time : int 517 533 542 544 554 554 555 557 557 558 ... ## $ sched_dep_time: int 515 529 540 545 600 558 600 600 600 600 ... ## $ dep_delay : int 2 4 2 -1 -6 -4 -5 -3 -3 -2 ... ## $ arr_time : int 830 850 923 1004 812 740 913 709 838 753 ... ## $ sched_arr_time: int 819 830 850 1022 837 728 854 723 846 745 ... ## $ arr_delay : int 11 20 33 -18 -25 12 19 -14 -8 8 ... ## $ carrier : chr &quot;UA&quot; &quot;UA&quot; &quot;AA&quot; &quot;B6&quot; ... ## $ flight : int 1545 1714 1141 725 461 1696 507 5708 79 301 ... ## $ tailnum : chr &quot;N14228&quot; &quot;N24211&quot; &quot;N619AA&quot; &quot;N804JB&quot; ... ## $ origin : chr &quot;EWR&quot; &quot;LGA&quot; &quot;JFK&quot; &quot;JFK&quot; ... ## $ dest : chr &quot;IAH&quot; &quot;IAH&quot; &quot;MIA&quot; &quot;BQN&quot; ... ## $ air_time : int 227 227 160 183 116 150 158 53 140 138 ... ## $ distance : int 1400 1416 1089 1576 762 719 1065 229 944 733 ... ## $ hour : int 5 5 5 5 6 5 6 6 6 6 ... ## $ minute : int 15 29 40 45 0 58 0 0 0 0 ... ## $ time_hour : chr &quot;2013-01-01 05:00:00&quot; &quot;2013-01-01 05:00:00&quot; &quot;2013-01-01 05:00:00&quot; &quot;2013-01-01 05:00:00&quot; ... ## - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt; 8.4 Data Manipulation with data.table In many cases, we need to inquiry and subset a dataset. Structured Query Language (SQL) is designed for that purpose. data.table syntax is actually very similar to the SQL syntax. data.table provides a simple, consistent, user-friendly syntax for data manipulation. The general form of data.table syntax is: DT[i, j, by] where DT is a data.table. by: grouped by what? j: what to do? i: on which rows? We will apply this form to manipulate data: Filtering rows, selecting columns, aggregating,  # # Filtering Rows Here we show how to filter particular rows with data.table. 8.4.1 Filtering rows through logical expression We can filter rows based on logical expression. E.g., # filtering flights with &quot;JFK&quot; as the origin in the month of June. tmp &lt;- flights[origin == &quot;JFK&quot; &amp; month == 6] head(tmp) ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## 1: 2013 6 1 2 2359 3 341 350 ## 2: 2013 6 1 538 545 -7 925 922 ## 3: 2013 6 1 539 540 -1 832 840 ## 4: 2013 6 1 553 600 -7 700 711 ## 5: 2013 6 1 554 600 -6 851 908 ## 6: 2013 6 1 557 600 -3 934 942 ## arr_delay carrier flight tailnum origin dest air_time distance hour minute ## 1: -9 B6 739 N618JB JFK PSE 200 1617 23 59 ## 2: 3 B6 725 N806JB JFK BQN 203 1576 5 45 ## 3: -8 AA 701 N5EAAA JFK MIA 140 1089 5 40 ## 4: -11 EV 5716 N835AS JFK IAD 42 228 6 0 ## 5: -17 UA 1159 N33132 JFK LAX 330 2475 6 0 ## 6: -8 B6 715 N766JB JFK SJU 198 1598 6 0 ## time_hour ## 1: 2013-06-01 23:00:00 ## 2: 2013-06-01 05:00:00 ## 3: 2013-06-01 05:00:00 ## 4: 2013-06-01 06:00:00 ## 5: 2013-06-01 06:00:00 ## 6: 2013-06-01 06:00:00 As see, this is much clear and easy to read compared to the syntax under data.frame; and we do not need to write flights$origin, flights$month as we did in data.frame. 8.4.2 Filtering rows by row index We can also filter rows by index. E.g., # filtering the first two rows from flights. flights[1:2] ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## 1: 2013 1 1 517 515 2 830 819 ## 2: 2013 1 1 533 529 4 850 830 ## arr_delay carrier flight tailnum origin dest air_time distance hour minute ## 1: 11 UA 1545 N14228 EWR IAH 227 1400 5 15 ## 2: 20 UA 1714 N24211 LGA IAH 227 1416 5 29 ## time_hour ## 1: 2013-01-01 05:00:00 ## 2: 2013-01-01 05:00:00 In data.table, .N is a special symbol that contains the number of rows of the data.table. E.g., # Return the last row of flights flights[.N] ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## 1: 2013 9 30 NA 840 NA NA 1020 ## arr_delay carrier flight tailnum origin dest air_time distance hour minute ## 1: NA MQ 3531 N839MQ LGA RDU NA 431 8 40 ## time_hour ## 1: 2013-09-30 08:00:00 # same as flights[336776] flights[336776] ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## 1: 2013 9 30 NA 840 NA NA 1020 ## arr_delay carrier flight tailnum origin dest air_time distance hour minute ## 1: NA MQ 3531 N839MQ LGA RDU NA 431 8 40 ## time_hour ## 1: 2013-09-30 08:00:00 8.4.3 Fitering rows through %between%, %chin%, %like% %between% allows you to search for numerical values in the closed interval [val1, val2]. The syntax is: numeric_col %between% c(val1, val2) # filtering all flights with arr_delay between 120 to 180 minutes tmp=flights[arr_delay%between% c(120, 180)] head(tmp) ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## 1: 2013 1 1 811 630 101 1047 830 ## 2: 2013 1 1 957 733 144 1056 853 ## 3: 2013 1 1 1114 900 134 1447 1222 ## 4: 2013 1 1 1505 1310 115 1638 1431 ## 5: 2013 1 1 1525 1340 105 1831 1626 ## 6: 2013 1 1 1549 1445 64 1912 1656 ## arr_delay carrier flight tailnum origin dest air_time distance hour minute ## 1: 137 MQ 4576 N531MQ LGA CLT 118 544 6 30 ## 2: 123 UA 856 N534UA EWR BOS 37 200 7 33 ## 3: 145 UA 1086 N76502 LGA IAH 248 1416 9 0 ## 4: 127 EV 4497 N17984 EWR RIC 63 277 13 10 ## 5: 125 B6 525 N231JB EWR MCO 152 937 13 40 ## 6: 136 EV 4181 N21197 EWR MCI 234 1092 14 45 ## time_hour ## 1: 2013-01-01 06:00:00 ## 2: 2013-01-01 07:00:00 ## 3: 2013-01-01 09:00:00 ## 4: 2013-01-01 13:00:00 ## 5: 2013-01-01 13:00:00 ## 6: 2013-01-01 14:00:00 %chin% is only for character vectors, it allows you to filter rows with character values in a set: character_col %chin% c(val1, val2, val3) # Filtering flights with &quot;JFK&quot; or &quot;LGA&quot; as origin in the month of May tmp &lt;- flights[origin %chin% c(&quot;JFK&quot;,&quot;LGA&quot;) &amp; month==5] head(tmp) ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## 1: 2013 5 1 9 1655 434 308 2020 ## 2: 2013 5 1 537 540 -3 836 840 ## 3: 2013 5 1 544 545 -1 818 827 ## 4: 2013 5 1 548 600 -12 831 854 ## 5: 2013 5 1 549 600 -11 804 810 ## 6: 2013 5 1 553 600 -7 700 712 ## arr_delay carrier flight tailnum origin dest air_time distance hour minute ## 1: 408 VX 413 N628VA JFK LAX 341 2475 16 55 ## 2: -4 AA 701 N5BYAA JFK MIA 144 1089 5 40 ## 3: -9 UA 450 N494UA LGA IAH 190 1416 5 45 ## 4: -23 B6 371 N523JB LGA FLL 140 1076 6 0 ## 5: -6 MQ 4650 N520MQ LGA ATL 113 762 6 0 ## 6: -12 EV 5747 N877AS LGA IAD 48 229 6 0 ## time_hour ## 1: 2013-05-01 16:00:00 ## 2: 2013-05-01 05:00:00 ## 3: 2013-05-01 05:00:00 ## 4: 2013-05-01 06:00:00 ## 5: 2013-05-01 06:00:00 ## 6: 2013-05-01 06:00:00 %like% allows you to search for a pattern in a character or a factor vector. It is best to illustrate what pattern means with an example. E.g., the two characters AA and AS (acronym for American Airline and Alaska Airlines) are both started with a upper case U. This is called a pattern. In R, ^A is used to denoted this pattern. We will talk more about pattern when we deal with strings. # filter carriers whose acronym starts with A. tmp &lt;- flights[carrier %like% &quot;^A&quot;] head(tmp) ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## 1: 2013 1 1 542 540 2 923 850 ## 2: 2013 1 1 558 600 -2 753 745 ## 3: 2013 1 1 559 600 -1 941 910 ## 4: 2013 1 1 606 610 -4 858 910 ## 5: 2013 1 1 623 610 13 920 915 ## 6: 2013 1 1 628 630 -2 1137 1140 ## arr_delay carrier flight tailnum origin dest air_time distance hour minute ## 1: 33 AA 1141 N619AA JFK MIA 160 1089 5 40 ## 2: 8 AA 301 N3ALAA LGA ORD 138 733 6 0 ## 3: 31 AA 707 N3DUAA LGA DFW 257 1389 6 0 ## 4: -12 AA 1895 N633AA EWR MIA 152 1085 6 10 ## 5: 5 AA 1837 N3EMAA LGA MIA 153 1096 6 10 ## 6: -3 AA 413 N3BAAA JFK SJU 192 1598 6 30 ## time_hour ## 1: 2013-01-01 05:00:00 ## 2: 2013-01-01 06:00:00 ## 3: 2013-01-01 06:00:00 ## 4: 2013-01-01 06:00:00 ## 5: 2013-01-01 06:00:00 ## 6: 2013-01-01 06:00:00 8.5 Select Columns The general form of data.table syntax is: DT[i, j, by] where by: grouped by what? j: what to do? i: on which rows? The second argument j is used to select (and compute on) columns. 8.5.1 Using column names to select columns Because data.table is an enhanced data.frame, we can select columns by column names in accordance with data.frame. # Select dep_delay and arr_delay column tmp &lt;- flights[, c(&quot;dep_delay&quot;,&quot;arr_delay&quot;)] # show the first 6 rows using head() function. head(tmp) ## dep_delay arr_delay ## 1: 2 11 ## 2: 4 20 ## 3: 2 33 ## 4: -1 -18 ## 5: -6 -25 ## 6: -4 12 # create a scatter plot between these two variables. plot(tmp) The plot shows that there is a strong linear relationship between dep_delay and arr_delay, which essentially means: if you deptures late by x minutes, you are very likely to arrive later by x minutes. Note that, as seen in flights[, c(dep_delay,arr_delay)], although we do not filter on rows, we need to include , to add a place holder for argument i. Otherwise, the code will generate an error msg. We can also select column based on the column index, which, however, is not strongly not recommended. flights[,c(6,9)] # dep_delay and arr_delay are at 6,9th column This is not recommended because if the order of columns changes (which is likely to happen if you are deleting or adding columns), the result will be wrong. We can also deselecting columns: -c(col1, col2) deselects the columns col1 and col2; in other words, delete col1 and col2. # disselect arr_delay and dep_delay column flights[,-c(&quot;dep_delay&quot;,&quot;arr_delay&quot;)] 8.5.2 Select columns as variables - the data.table way In data.table, each column is treated as a variable, thus, you can use a list of variables (column names) to select columns. # Select the arr_delay and dep_delay column. tmp &lt;- flights[, list(dep_delay,arr_delay)] The difference of this code and the above code is that dep_delay and arr_delay are not inside \"\". This is because dep_delay and arr_delay are treated as variable, rather column names. .() is an alias to list(), for convenience. We can use .() to replace list(). This reduces typing and allows you to focus on the variables that are selected when reading the code. tmp &lt;- flights[, .(dep_delay,arr_delay)] We can also rename the column while selecting the column. E.g., the following code select arr_delay and dep_delay and rename to arrive_delay and depart_delay tmp &lt;- flights[, .(arrive_delay = arr_delay, depart_delay = dep_delay)] head(tmp) ## arrive_delay depart_delay ## 1: 11 2 ## 2: 20 4 ## 3: 33 2 ## 4: -18 -1 ## 5: -25 -6 ## 6: 12 -4 8.5.3 Computing on columns Since columns in data.table can be referred to as variables, you can compute directly on them in j. We will find this is a quick and easy way to get summary statistics from the data. E.g., you want to know the average arr_delay and dep_delay of all the fligths? in other words, you want to compute the mean of arr_delay and dep_delay. # calcuate the mean arr_delay flights[,mean(arr_delay)] ## [1] NA flights[,mean(arr_delay, na.rm = TRUE)] ## [1] 6.895377 We can also rename the calculated columns: # calcuate the mean arr_delay and dep_delay flights[,.(mean(arr_delay, na.rm = TRUE), mean(dep_delay, na.rm = TRUE))] ## V1 V2 ## 1: 6.895377 12.63907 You can compute and name multiple variables at the same time: # calcuate the mean arr_delay and dep_delay flights[,.(avg_arr_delay=mean(arr_delay, na.rm = TRUE), avg_dep_delay=mean(dep_delay, na.rm = TRUE))] ## avg_arr_delay avg_dep_delay ## 1: 6.895377 12.63907 8.5.4 Computing on rows and columns Combining i and j is straightforward. E.g., you want to compute the average arr_deply and dep_deply for all flights origined from JFK in the month of Jun flights[origin==&quot;JFK&quot; &amp; month==6,.(avg_arr_delay=mean(arr_delay, na.rm = TRUE), avg_dep_delay=mean(dep_delay, na.rm = TRUE))] ## avg_arr_delay avg_dep_delay ## 1: 17.59693 20.49973 Now, let break this code to understand how it works. We first subset in i to find matching row indices where origin airport equals JFK, and month equals 6; next we look at j and select the two columns and compute their mean(). Note that the code will return a data.table. 8.5.5 Special symbol .N in j Remember .N denotes the number of rows. .N can be used in j as well. It is particularly useful to get the number of rows after filtering in i. E.g., you want to compute how many flights are delayed (i.e., arr_delay + dep_delay&gt;0). flights[arr_delay + dep_delay&gt;0, .N] ## [1] 135059 In the above code, the data.table is first filtered by arr_delay + dep_delay&lt;=0, and then compute the number of selected rows. 8.5.6 Advanced Computation on columns Because the columns can be treated as variable in data.table, thus we can perform complex calculation on these variable in j. E.g., we want to compute the average speed of all flights, where speed is measured by distance/(airm_time/60) (miles per hour)? flights[, .(miles_per_hr=mean( 60*distance/air_time , na.rm = TRUE))] ## miles_per_hr ## 1: 394.2737 8.5.7 Sort Data by One/Multiple Columns The data.table has very simple syntax to sort data based on one/multiple columns. E.g., sort flights first by origin in ascending order, and then by dest in descending order # Use the order() function to sort by columns. tmp &lt;- flights[order(origin, -dest)] head(tmp) ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## 1: 2013 1 2 905 822 43 1313 1045 ## 2: 2013 1 3 848 850 -2 1149 1113 ## 3: 2013 1 4 901 850 11 1120 1113 ## 4: 2013 1 6 843 848 -5 1053 1111 ## 5: 2013 1 7 858 850 8 1105 1113 ## 6: 2013 1 8 847 850 -3 1116 1113 ## arr_delay carrier flight tailnum origin dest air_time distance hour minute ## 1: NA EV 4140 N15912 EWR XNA NA 1131 8 22 ## 2: 36 EV 4125 N21129 EWR XNA 196 1131 8 50 ## 3: 7 EV 4125 N16178 EWR XNA 168 1131 8 50 ## 4: -18 EV 4625 N12172 EWR XNA 174 1131 8 48 ## 5: -8 EV 4125 N13118 EWR XNA 163 1131 8 50 ## 6: 3 EV 4125 N14180 EWR XNA 177 1131 8 50 ## time_hour ## 1: 2013-01-02 08:00:00 ## 2: 2013-01-03 08:00:00 ## 3: 2013-01-04 08:00:00 ## 4: 2013-01-06 08:00:00 ## 5: 2013-01-07 08:00:00 ## 6: 2013-01-08 08:00:00 8.6 Calcuation by Group Weve already seen i and j from data.tables general form. Here, well see how they can be combined together with by to perform operations by group. E.g., how can we get the number of flights corresponding to each origin airport? flights[, .(count=.N), by = .(origin)] ## origin count ## 1: EWR 120835 ## 2: LGA 104662 ## 3: JFK 111279 e.g., How can we get the total number of flights and average arrival delay and std deviation of arrial delay for each origin, dest pair for carrier code AA? tmp&lt;-flights[carrier == &quot;AA&quot;, .(count=.N, avg_arr_delay=mean(arr_delay, na.rm = TRUE), sd_arr_delay=sd(arr_delay, na.rm = TRUE)), by = .(origin, dest)] head(tmp) ## origin dest count avg_arr_delay sd_arr_delay ## 1: JFK MIA 2221 -3.23122440 36.81734 ## 2: LGA ORD 5694 -1.31396831 41.07306 ## 3: LGA DFW 4836 -1.18901523 39.21697 ## 4: EWR MIA 1068 0.06332703 54.78252 ## 5: LGA MIA 3945 -1.64248971 37.45564 ## 6: JFK SJU 1099 -0.77603687 37.28137 From this summary, we can see that AA on average arrive on time. However, the high std deviation means there is great variation in terms of the arrive delay. How can we get the average arrival and departure delay for each origin, dest pair for each month for carrier code AA? tmp=flights[carrier == &quot;AA&quot;, .(avg_arr_delay=mean(arr_delay), avg_dep_delay=mean(dep_delay)), by = .(origin, dest, month)] # plot the avg_arr_delay, avg_dep_delay and use color to mark different month library(ggplot2) ggplot(tmp,aes(avg_arr_delay, avg_dep_delay, color=factor(month)))+ geom_point() ## Warning: Removed 151 rows containing missing values (geom_point). The data.table summary and the plot together provide a great way to visualize which month are more likely to have flights delay. Note that, the above code retain the original ordering of origin-dest pair. There are cases when preserving the original order is essential. However, if we want to automatically sort by the variables in our grouping, we can simply change by to keyby # sort by origin, dest, month tmp &lt;- flights[carrier == &quot;AA&quot;, .(avg_arr_delay=mean(arr_delay, na.rm = TRUE), avg_dep_delay=mean(dep_delay, na.rm = TRUE)), keyby = .(origin, dest, month)] head(tmp) ## origin dest month avg_arr_delay avg_dep_delay ## 1: EWR DFW 1 8.042945 9.587879 ## 2: EWR DFW 2 8.222222 11.855172 ## 3: EWR DFW 3 1.113095 16.035503 ## 4: EWR DFW 4 13.067485 16.713415 ## 5: EWR DFW 5 -6.158537 10.053571 ## 6: EWR DFW 6 4.148148 18.153374 Notice that, the datatable is ordered based on variables in our grouping (origin-dest-month). This is easy for reader to examine the the pattern in our data in a tabular form. 8.7 Summary R has currently 120,000 packages, which can enhance the power of base R. data.table is a enhanced verison of data.frame to handle big data. Learn how to install and load R packages. data.table syntax: DT[i, j, by]: by - grouped by what; j - what to do; i - on which rows. use data.table syntax to manipulate the flights dataset: filtering rows, selecting columns; computing columns; aggregrating by group. "],["references.html", "References", " References "]]
