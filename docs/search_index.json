[["index.html", "A Minimal Book Example Chapter 1 Prerequisites", " A Minimal Book Example Yihui Xie 2021-08-23 Chapter 1 Prerequisites This is a sample book written in Markdown. You can use anything that Pandocs Markdown supports, e.g., a math equation \\(a^2 + b^2 = c^2\\). This is a testing of bookdown. The bookdown package can be installed from CRAN or Github: install.packages(&quot;bookdown&quot;) # or the development version # devtools::install_github(&quot;rstudio/bookdown&quot;) Remember each Rmd file contains one and only one chapter, and a chapter is defined by the first-level heading #. To compile this example to PDF, you need XeLaTeX. You are recommended to install TinyTeX (which includes XeLaTeX): https://yihui.name/tinytex/. "],["chapter01.html", "Chapter 2 Define Variables 2.1 Use R as a Calculator 2.2 Define variables 2.3 Basic Variable Modes: integer, numeric, character, logical, factor. 2.4 Exercise 1: Greeting from R 2.5 Exercise 2: Mortgage Calculation 2.6 Summary", " Chapter 2 Define Variables Here is the guideline in how to read this document: The shaded area (with green backgroud) is R code. Within the shaded area, # The hashtag means This is a comment. The comment is to help yourself and others to understand what the code does. The line right next to the code (starting with ##) is the output of the code. 2.1 Use R as a Calculator R can be used as a powerful calculator by entering equations directly at the prompt in the command console. Simply type your arithmetic expression and press ENTER. # R is highly interactive, you can get instant feedback while coding. 3+6 ## [1] 9 # To execute the above command, put the mouse anywhere in the line and hit &quot;Ctrl+Enter&quot;. # the product of 2 and 4 2*4 ## [1] 8 # 6 divided by 7 6/7 ## [1] 0.8571429 # 2 to the power of 10 2^10 ## [1] 1024 # x%%y return the reminder of x divided by y 10%%3 ## [1] 1 2.2 Define variables The most basic concept in programming is variable. A variable allows you to store a value (e.g. 4) or an object (e.g. a function) in R; and you can then later use this variables name to easily access the value or the object that is stored within this variable. The &lt;- symbol (&lt; and -) or = symbol means Set the variable on the left equal to the thing on the right. In RStudio the keyboard shortcut for the assignment operator &lt;- is Alt + - (Windows) or Option + - (Mac). For example, you can save you age to a varaible my_age through the following code: # Assign the variable &quot;my_age&quot; the value of 30. # The &quot;&lt;-&quot; or &quot;=&quot; symbol assigns right hand side (RHS) to the left hand side(LHS) my_age&lt;-30 You have just defined a variable my_age with value of 30, which is stored in the computer now. Now look at the up right corner of R-studio, you should see the defined variable. To print my_age on the screen, type in my_age (without quotes) and hit Ctrl+Enter. It will show you the value. my_age ## [1] 30 Or we can use the print() function to print the variable on the screen. print(my_age) ## [1] 30 Now, you need to define two more variables to save the age of the father and mother: mother_age with value of 60, and father_age with value of 65. mother_age&lt;-60 father_age&lt;-65 The defined the variables are saved in computer memory, and you can use the defined variable for calculation. # How much the father is older than the child? father_age-my_age ## [1] 35 # How much the father is older than the mother? father_age-mother_age ## [1] 5 We can define a new variable through the calculation on the existing variables. Define a variable avg_age with the value the average age of the parents. avg_age=(father_age+mother_age)/2 avg_age ## [1] 62.5 Variable names are like our human names, which uniquely identify the value stored in computer. It is best practice to use variable names that can be easily understood. Try to use English word and \"_\" to make it self-explanatory. Also, try to use lower case consistently because R is case-sensitivity. It will be hard to remember which letter is upper case and which is not. 2.3 Basic Variable Modes: integer, numeric, character, logical, factor. In the physical world, we have different mode of data. E.g., 30 is a an integer (a more specific type of numeric); 51.67 is a number; Leon is a character; TRUE/FALSE is logical; The color like blue/green/red is categorical. In R such categorical variable is called factor. R use different variable mode to store these different type of data. 2.3.1 Integer and numeric Recall that we define my_age as a number. Type class(my_age) to checkt the model of the variable. Note: class(): is a built-in R function which returns the mode of a variable. We will talk later what is function. # Type class(my_age) to check the mode of variable &quot;my_age&quot; class(my_age) ## [1] &quot;numeric&quot; To specifically define a variable as an integer, add letter L after the number. Define my_age=30L and check its mode. my_age=30L class(my_age) ## [1] &quot;integer&quot; You may be wondering why bother to differentiate integer and numeric; after all, they are all numbers. However, there is an important thing to remember: computer uses combination of 0/1 to save any values. While integer can always be exactly represented in 0/1 byte, non-integer may not be and thus lead to rounding error. Lets look at one example. It should be a no-brainer that sqrt(3)^2 should equals to 3. However, this is not the case in R (or any other programming languages). Try sqrt(3)^2==3 to compare these two number and see the result: # == is the logical operator to compare whether LHS equals RHS sqrt(3)^2==3 ## [1] FALSE Surprisingly, the output is FALSE, i.e., the computer makes a verdict that sqrt(3)^2 does not equal 3. This is because computer first computes sqrt(3), which is a non-integer with infinite decimal. To save this number in memory, sqrt(3) will be rounded. As a result, its square is not exactly 3. But in most cases, we do not need to overly concerned about rounding errors because the difference is negligible. 2.3.2 Logical In the above example, we introduced the logical operator == to compare numbers. The logical operator returns logical variable which takes value of only TRUE or FALSE. The typical Logical Operators in R: Operator Description &lt; less than &lt;= less than or equal to &gt; greater than &gt;= greater than or equal to == exactly equal to != not equal to !x Not x x y x &amp; y x AND y isTRUE(x) test if X is TRUE Now, lets check the mode of the result of the comparison sqrt(3)^2==3 using the class() function. class(sqrt(3)^2==3) ## [1] &quot;logical&quot; Similarly, you define a logical variable by assigning the comparison results into a logical variable # type 3&gt;2 and assign the value to a variable compare # check the variable class of the variable compare compare&lt;-3&gt;2 compare ## [1] TRUE class(compare) ## [1] &quot;logical&quot; We can use &amp; (and) and | (or ) for logical calcuation. compare1&lt;-3==2 # 3 equals to 2 is FALSE compare2&lt;-3!=2 # 3 not equal to 2 is TRUE compare1 &amp; compare2 # x &amp; y: true only if both x and y are true; otherwise false. ## [1] FALSE compare1 | compare2 # x | y: false only if both x and y are false; otherwise true. ## [1] TRUE Now, compare the mother_age and father_age to see who is older? father_age&gt;mother_age ## [1] TRUE 2.3.3 Character Suppose we want to save my name into a variable, how can I do that? This involves a new type of variable: character (also known as string). The character variable is defined by \"; anything inside\" will be saved as the character. # Type my_name=&quot;Leon Xu&quot; and use class() to check its mode. my_name&lt;-&quot;Leon Xu&quot; my_name ## [1] &quot;Leon Xu&quot; class(my_name) ## [1] &quot;character&quot; Now, you need to define character variable first_name with value Leon; and define character variable last_name with value Xu;. first_name=&quot;Leon&quot; last_name=&quot;Xu&quot; Given, the first and last name, we can combine the two strings into the full name. Note that the Arithmetic operators (+-*/) are not defined over strings. We need to use string-specific functions. You can use paste() function to concatenate the two string together. full_name=paste(first_name, last_name, sep=&quot; &quot;) # sep=&quot; &quot; means to seperates the strings with a space. full_name ## [1] &quot;Leon Xu&quot; type ?paste to get the help document on this function. ?paste Again, string is defined using \"\". To better understand that, run the following code to see the difference: print(10+1) print(&quot;10+1&quot;) print(leon xu) print(10+1): 10+1 is not inside \"\", so computer will read and interpret 10+1 and return 11 as the result. print(10+1): 10+1 is insdie \"\", so computer knows this is a strings and will not interpret it and keep it intact. print(leon xu): leon xu is not inside \"\"; so computer will read it and try to interpret it. Because computer (which is good at number and computation) cannot understand the string, thus returns error. It is one of the most common mistake to forget \"\" when you actually means to define a character. 2.3.4 Type coercion Sometime we need to convert from one variable mode to another. This typically happens when we read data from computer or web (e.g., csv) into R because computer is not smart enough to guess the variable type correctly. The good news is that we can easily convert from one variable mode to another. e.g., define the following two variables: var1=&quot;3&quot; # this is a character var2=4 # this is a numeric class(var1) ## [1] &quot;character&quot; class(var2) ## [1] &quot;numeric&quot; # Type var1+var2 and run the code; this will cause an error because var1 is a character var1+var2 The code below shows how to convert a character to numeric. var1&lt;-as.numeric(var1) var1+var2 ## [1] 7 The type coercion functions: # convert character &quot;4&quot; to 4; as.numeric(&quot;4&quot;) ## [1] 4 # convert 4 to character &quot;4&quot; as.character(4) ## [1] &quot;4&quot; # convert logical to numeric as.numeric(FALSE) # FALSE is stored as 0 in the computer ## [1] 0 as.numeric(TRUE) # TRUE is stored as 1 in the computer ## [1] 1 # we can sum TRUE/FALSE since they are saved as 1/0 TRUE+TRUE+FALSE ## [1] 2 We cannot force type coercion when the it is clearly not possible. For example, we cannot change the character John to a number. In this case, the R will generate NA (missing value in R) var&lt;-as.numeric(&quot;John&quot;) # var will be assigned NA (not available) ## Warning: NAs introduced by coercion # is.na() is R function to check whether a variable is NA is.na(var) ## [1] TRUE # NA is contagious in R; operations over NA results in NA var+1 ## [1] NA In R programming, everything stored in your computer are Objects. The variable we defined are also objects. Look for your objects in the upper right of the RStudio area # type ls() to see the objects stored in the computer ls() ## [1] &quot;avg_age&quot; &quot;compare&quot; &quot;compare1&quot; &quot;compare2&quot; &quot;father_age&quot; ## [6] &quot;first_name&quot; &quot;full_name&quot; &quot;last_name&quot; &quot;mother_age&quot; &quot;my_age&quot; ## [11] &quot;my_name&quot; &quot;var&quot; &quot;var1&quot; &quot;var2&quot; # you can remove objects through rm(). Remove the variable firstname rm(var) 2.4 Exercise 1: Greeting from R In this exercise, we will create a customized greeting from R to you. We will write a code to let the computer ask your name and age and print a customized greeting. This seems first overwhelming. In computer programming, one philosophy is always to break a complicated task into small piece and build upon that. Lets do the version 1: # Send a customized greeting based on your name (e.g., Leon) and age (e.g., 30) # Suppose it takes 1 year to master R programming print(&quot;Hello Leon, welcome to the world of R!&quot;) ## [1] &quot;Hello Leon, welcome to the world of R!&quot; print(&quot;You will be empowered by R to do awesome data analytics by the age 31!&quot;) ## [1] &quot;You will be empowered by R to do awesome data analytics by the age 31!&quot; Well, this is simple, but we need to customize so that it print your name and age information. Lets do the version 2: # Define your name and age (change to your name and age) name=&quot;Leon&quot; age=30 # Send a customized greeting based on your name and age # We need to paste the name and age to the greeting greeting1&lt;-paste(&quot;Hello &quot;, name, &quot;, welcome to the world of R!&quot;, sep = &quot;&quot;) greeting2&lt;-paste(&quot;You will be empowered by R to do awesome data analytics by the age &quot;, age+1, &quot;!&quot;, sep=&quot;&quot;) print(greeting1) ## [1] &quot;Hello Leon, welcome to the world of R!&quot; print(greeting2) ## [1] &quot;You will be empowered by R to do awesome data analytics by the age 31!&quot; Lets do the version 3: we will make it more interactive by using a function readline(), which asks for input from user through keyboard. # Use the console to input your name and age: name=readline(&quot;What is your name: &quot;) age=readline(&quot;How old are you: &quot;) # readline() always return a character age&lt;-as.numeric(age) # Send a customized greeting based on your name and age # We need to paste the name and age to the greeting greeting1&lt;-paste(&quot;Hello &quot;, name, &quot;, welcome to the world of R!&quot;, sep = &quot;&quot;) greeting2&lt;-paste(&quot;You will be empowered by R to do awesome data analytics by the age &quot;, age+1, &quot;!&quot;, sep=&quot;&quot;) print(greeting1) print(greeting2) 2.5 Exercise 2: Mortgage Calculation Support you are working at a bank provides mortgage loan. One important task is to calculate the monthly mortgage payment for any given loan. You can use the following equation to calculate the monthly mortgage payment (not including taxes and insurance): \\[M = P ( i(1 + i)^n ) / ( (1 + i)^n - 1)\\] where P = principal loan amount i = annual_interest_rate/12, i.e., i is the monthly interest rate, which is the annual interest rate divided by 12 n = number of months required to repay the loan Develop a program to calculate the monthly mortgage payment for a loan with: P=350000; annual_interest_rate=3.25%; year_repay=30. Once you calculate the monthly payment, print the result on the screen \"Your month mortgage payment is: ***\" # Define the loan P=350000 # loan amount annual_rate=0.0325 # Convert % into decimal to avoid error year_repay=30 # number of year to repay n=12*30 # number of month to repay i=annual_rate/12 payment = P*( i*(1 + i)^n ) / ( (1 + i)^n - 1) payment = round(payment,digits=0) print(paste(&quot;Your monthy mortage payment is $&quot;, payment, sep=&quot;&quot;)) ## [1] &quot;Your monthy mortage payment is $1523&quot; 2.6 Summary Learn to do basic arithmetic operations (+,-,*,/,^,%%) in R. Learn to define variable and the rule in naming variables. Understand the different variable mode (or type): integer, numeric, logical, character Understand how convert from one tpye to another. Learn to create the first interactive program using print() and readline() functions. "],["data-structure-vector-matrix-list-and-factor.html", "Chapter 3 Data Structure: Vector, Matrix, List and Factor 3.1 Vector 3.2 Matrices 3.3 Factors 3.4 List 3.5 Summary", " Chapter 3 Data Structure: Vector, Matrix, List and Factor It is ineffecicent to store each data point as a single-value variable. Think of dataset with 1000 rows and 20 columns, it will requires 20,000 single-value variables to store the data. In R, there are more efficient ways to store an array of data. Here we will introduce a few common data structure in R, including vector, matrix, data frame, and list. In addition, we all also talk about the factor: the data mode to represent categorical variable in R. 3.1 Vector Vector is a one-dimensional array that can hold numeric data, character data, or logical data. # Assign x the value c(1, 2, 3, 4, 10) (Here, &quot;c&quot; means vector) x=c(1,2,3,4,10) Notice that, after running the code, it seems nothing happen on the output screen. This is because this code only tells the computer to create a vector x with value of c(1, 2, 3, 4, 10). You can type x to print it on the screen. One simple trick to print x is to put the code inside () as follow: (x=c(1,2,3,4,10)) ## [1] 1 2 3 4 10 You can also create vector using a R-function seq(): y=seq(from=1, length=5, by=2), which creates a vector with length of 5, starting from 1 with step of 2. seq() is a very useful function to generate sequence, specially when we construct for loop. (y=seq(from=1,length=5,by=2)) ## [1] 1 3 5 7 9 # check the help document of the function by typing ?seq. Now, suppose you are at SpaceX launching center, you want to count down from 10 to 1. Use seq() to generate a sequence from 10 to 1. seq(from=10,length=10,by=-1) ## [1] 10 9 8 7 6 5 4 3 2 1 seq(from=10,to=1,by=-1) ## [1] 10 9 8 7 6 5 4 3 2 1 There is another quick way to generate a sequence of integer with interval of 1 using colon: # type 1:10 to define a vector from 1 to 10 with interval of 1. 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 # type 10:1 to define a vector from 10 to 1 with interval of -1. 10:1 ## [1] 10 9 8 7 6 5 4 3 2 1 So far, the element of a vector is numerical. The element of a vector can also be character or logical. # define a character vector b=c(&quot;one&quot;,&quot;two&quot;,&quot;three&quot;) b=c(&quot;one&quot;,&quot;two&quot;,&quot;three&quot;) b ## [1] &quot;one&quot; &quot;two&quot; &quot;three&quot; class(b) ## [1] &quot;character&quot; # define a logical vector c=c(TRUE,FALSE,FALSE) c=c(TRUE,FALSE,FALSE) c ## [1] TRUE FALSE FALSE class(c) ## [1] &quot;logical&quot; The element of a vector must be the same type. Otherwise, R will force type coercion: convert all elements into character. Of course, we should aviod such forced type coercion by making sure all elements in the vector are the same type. For example, type d=c(4,3) and e=c(a, TRUE) and then print these two vectors, which are forced to be converted to character. d=c(4,&quot;3&quot;) e=c(&quot;a&quot;, TRUE) d ## [1] &quot;4&quot; &quot;3&quot; e ## [1] &quot;a&quot; &quot;TRUE&quot; 3.1.1 Subsetting vectors The vector is like an one-dimensional container for data. Once we create the vector, we can retrieve the elements from the vector according to the index. # define x=c(1,2,3,4,10) x=c(1,2,3,4,10) # retrieve the 2rd element of x by typing x[2]. x[2] ## [1] 2 It is important to notice that [] is the operator for subsetting the vector. It is a common mistake to type x(2), which means calling the function named x and passing argument 2 to the function. You can also retrieve multiple element for a vector at the same time. # retrieve the 1st, 3rd and 5th element of x x[c(1,3,5)] ## [1] 1 3 10 # retrieve the 2rd to 5th elements of x using colon operator x[2:5] ## [1] 2 3 4 10 The negative index means to retrieve every element from a vector except the negative index one, e.g., # retrieve every element of x except the 2rd element x[-1] ## [1] 2 3 4 10 We can also retrieve elements from vector by logical operator. E.g., # retrieve elements of x that is less than 5 x[x&lt;5] ## [1] 1 2 3 4 We cannot retrieve element from a vector which is beyond its length. E.g., if you type x[6], that will return NA (i.e., missing value) because the x only have 5 elements. x[6] Thus, it is important to know the length of a vector to aviod such error. # Find the length of &quot;x&quot; using &quot;length(x)&quot; length(x) ## [1] 5 3.1.2 Vector calculus We can perform operation on vector just as we perform operation on their individual elements. E.g., when the element of vector is numeric, you can perform operation (+, -, *, /) on each element of a vector. n=4 x=c(1,2,3,4,10) # Multiply x * n x*n ## [1] 4 8 12 16 40 # divide x/n x/n ## [1] 0.25 0.50 0.75 1.00 2.50 # addition x+n x+n ## [1] 5 6 7 8 14 # minus x-n x-n ## [1] -3 -2 -1 0 6 # power x^n x^n ## [1] 1 16 81 256 10000 We can also perform operation (+,-,*,/) with two vectors x=c(1,2,3,4,10) y=1:5 # multiply x * y : the corresponding elements will multiply each other. x*y ## [1] 1 4 9 16 50 # divide x/y: the corresponding elements will divide each other. x/y ## [1] 1 1 1 1 2 # addition x+y: the corresponding elements will add each other. x+y ## [1] 2 4 6 8 15 # minus x-y: the corresponding elements will minus each other. x-y ## [1] 0 0 0 0 5 # x^y: the x to the power of the corresponding element in y x^y ## [1] 1 4 27 256 100000 We can also use built-in R function to get summry about a vector. # Find the mean, median, min, and max of the numebers in &quot;x&quot; mean(x) ## [1] 4 median(x) ## [1] 3 min(x) ## [1] 1 max(x) ## [1] 10 summary(x) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 1 2 3 4 4 10 3.2 Matrices A matrix is a two-dimensional array where each element has the same type (numeric, character, or logical). Matrices are created with the matrix function. The general format is: myymatrix = matrix(vector, nrow=number_of_rows, ncol=number_of_columns, byrow=logical_value, dimnames=list( char_vector_rownames, char_vector_colnames)) # type ?matrix to get the help document on matrix() ?matrix Lets make a matrix m=matrix(1:6, nrow = 3, ncol = 2). Note that we are not passing value to the arguments such as byrow and dimnames. In such case, the R will take the default value for these argumements. # with matrices, it always fills column by column by default. m = matrix(1:6, nrow = 3, ncol = 2) # print matrix m m ## [,1] [,2] ## [1,] 1 4 ## [2,] 2 5 ## [3,] 3 6 Now, find the dimension of m so that we can retrieve its element. # type dim(m) to get the rows and columns dim(m) ## [1] 3 2 # type nrow(m) and ncol(m) to get the rows and columns respectively nrow(m) ## [1] 3 ncol(m) ## [1] 2 We can fill the matrix by rows by setting byrow to be TRUE # create a matrix, filling by rows matrix(1:6,nrow=3, ncol=2, byrow=TRUE) ## [,1] [,2] ## [1,] 1 2 ## [2,] 3 4 ## [3,] 5 6 We can also stack multiple vector to become a matrix. Depending on whether we want to stack the vector by column or by row, we can use cbind() and rbind() function. # create matrix through column bind cbind(): m2=cbind(c(1,3,4) c(2,34,5)) m2=cbind(c(1,3,4),c(2,34,5)) m2 ## [,1] [,2] ## [1,] 1 2 ## [2,] 3 34 ## [3,] 4 5 # create matrix through row bind rbind: m3=rbind(c(1,3,4), c(2,34,5)) m3=rbind(c(1,3,4), c(2,34,5)) m3 ## [,1] [,2] [,3] ## [1,] 1 3 4 ## [2,] 2 34 5 3.2.1 subsetting matrix Matrix is a 2-dimensional container to store the data point. Once the matrix is defined, we can retrieve element from the matrix according to its index. # To retrieve the &quot;element&quot; in the second row and first column we # type &quot;m[2,1]&quot;. Again, the square brackets are used to retrieve part of a vector or matrix. # If we want the entire second column we type in &quot;m[,2]&quot;. This means &quot;all rows, second column 2&quot; # If we want the entire third row, we type in &quot;m[3,]&quot;. This means &quot;third row, all columns&quot; m[2,1] ## [1] 2 m[,2] ## [1] 4 5 6 m[3,] ## [1] 3 6 You can also retrieve elements from matrix using colon operator, e.g., # retrieve elements at row 1-2, and 2th column m[1:2,2] ## [1] 4 5 Similar to vector, elements of a matrix have to be the same type. otherwise, R will force type coercion. E.g., # define a matrix with numerics m4=matrix(1:8,ncol=2) m4 ## [,1] [,2] ## [1,] 1 5 ## [2,] 2 6 ## [3,] 3 7 ## [4,] 4 8 # define a matrix with character. char=matrix(c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;), nrow=4) char ## [,1] ## [1,] &quot;a&quot; ## [2,] &quot;b&quot; ## [3,] &quot;c&quot; ## [4,] &quot;d&quot; Now combine the two matrixes m4 and char through cbind() m5=cbind(m4,char) m5 ## [,1] [,2] [,3] ## [1,] &quot;1&quot; &quot;5&quot; &quot;a&quot; ## [2,] &quot;2&quot; &quot;6&quot; &quot;b&quot; ## [3,] &quot;3&quot; &quot;7&quot; &quot;c&quot; ## [4,] &quot;4&quot; &quot;8&quot; &quot;d&quot; All elements of the matrixes are converted to character. 3.2.2 matrix calculus You can perform operation (+, -, *, /) on each element of a vector. # Multiply m * n n=10 m = matrix(1:6, nrow = 3, ncol = 2) m*n ## [,1] [,2] ## [1,] 10 40 ## [2,] 20 50 ## [3,] 30 60 # divide x/n m/n ## [,1] [,2] ## [1,] 0.1 0.4 ## [2,] 0.2 0.5 ## [3,] 0.3 0.6 # addition x+n m+n ## [,1] [,2] ## [1,] 11 14 ## [2,] 12 15 ## [3,] 13 16 # minus x-n m-n ## [,1] [,2] ## [1,] -9 -6 ## [2,] -8 -5 ## [3,] -7 -4 We can also use the built-in R functions to perform matrix calcuation. The colSums and rowSums are two useful function for matrix. # type colSums(m) to obtain the sum of each column of matrix m colSums(m) ## [1] 6 15 # type rowSums(m) to obtain the sum of each row of matrix m rowSums(m) ## [1] 5 7 9 apply() is a handy function for matrix calcuation. The general format of apply() function is: apply(matrix, margin, function) margin=1 indicates applying each row of the matrix to the function. margin=2 indicate applying each column of the matrix to the function. # E.g., calculating the mean of each row apply(m,1,mean) ## [1] 2.5 3.5 4.5 # E.g., calculating the sum of each column apply(m,2,sum) ## [1] 6 15 3.3 Factors Many data are categorical: e.g., the patients diabetes type (type 1 or type 2), the movie type (action, sci-fi, comedy), the customer satisfaction level (poor, good excellent) to a call service. # define a vector of diabetes type diabetes = c(&quot;Type1&quot;, &quot;Type2&quot;, &quot;Type1&quot;, &quot;Type1&quot;) class(diabetes) ## [1] &quot;character&quot; We need to convert the diabetes vector into factor to represent that this is a categorical variable. We can do that through the factor() function: diabetes = factor(diabetes) class(diabetes) ## [1] &quot;factor&quot; str(diabetes) ## Factor w/ 2 levels &quot;Type1&quot;,&quot;Type2&quot;: 1 2 1 1 Note that str() is a very handy function in R. It examines the structure of any objects in R. We use this function to examine the factor. As shown, diabetes has two levels: Type1 and Type2. They are coded as 1 and 2 respectively. Take an another example. Suppose we are buidling a database for movies. The movie_type is the vector which stores the type of each movie in the database. # define a vector of movie type movie_type=c(&quot;sci-fi&quot;,&quot;comedy&quot;,&quot;sci-fi&quot;,&quot;action&quot;,&quot;action&quot;) str(movie_type) ## chr [1:5] &quot;sci-fi&quot; &quot;comedy&quot; &quot;sci-fi&quot; &quot;action&quot; &quot;action&quot; movie_type = factor(movie_type) str(movie_type) ## Factor w/ 3 levels &quot;action&quot;,&quot;comedy&quot;,..: 3 2 3 1 1 Note that both diabetes and movie are unordered because it does not make sense to compare each category in both cases. There are also situations we need ordered factor, i.e., age group, education level, etc. In marketing, we typically run customer satisfaction survey on a 1-5 scale, where 1 means poor, 2 fair, 3 good and 4 improved and 5 excellent. This is called ordered factor: they are categorical but you can compare different category. # Here is a vector of survey response from 6 different customers survey_response=c(1,3,5,2,3,5) # convert this vector into a vector of factor with the corresponding labels survey_response2=factor(survey_response,order=TRUE,levels=c(1,2,3,4,5),labels=c(&quot;poor&quot;,&quot;fair&quot;,&quot;good&quot;,&quot;improved&quot;, &quot;excellent&quot;)) survey_response2 ## [1] poor good excellent fair good excellent ## Levels: poor &lt; fair &lt; good &lt; improved &lt; excellent str(survey_response2) ## Ord.factor w/ 5 levels &quot;poor&quot;&lt;&quot;fair&quot;&lt;..: 1 3 5 2 3 5 In the above code, levels and labels describe the level and their corresponding labels for this categorical variable. Note you need to put levels in their ascending order. As seen, the original response is coded in 1-5. Without proper labels, it would be very difficult to understand what 1-5 means. Thus, the R Factor is very useful to deal with such coded categorical variables. Since this is a ordered factor, we can compare between different level survey_response2[1] # no longer a number, but a coded level. ## [1] poor ## Levels: poor &lt; fair &lt; good &lt; improved &lt; excellent survey_response2[2] ## [1] good ## Levels: poor &lt; fair &lt; good &lt; improved &lt; excellent # we can compare level since this is a ordered factor survey_response2[1]&gt;survey_response2[2] ## [1] FALSE As mentioned, everything in R (e.g., the variable we defined and the function) is an object. We can use str() to examine the structure of any objecxt. # use str() to examine data in R str(movie_type) ## Factor w/ 3 levels &quot;action&quot;,&quot;comedy&quot;,..: 3 2 3 1 1 str(survey_response2) ## Ord.factor w/ 5 levels &quot;poor&quot;&lt;&quot;fair&quot;&lt;..: 1 3 5 2 3 5 # use str() to examine function str(factor) ## function (x = character(), levels, labels = levels, exclude = NA, ordered = is.ordered(x), ## nmax = NA) str(str) ## function (object, ...) 3.4 List Lists are the most complex of the R data types. Basically, a list is an collection of all kinds of objects (components). The many complex function returns list as function output, thus it is very important to know this data structure. Create a list: list(obj1, obj2, ) obj1, obj2,  can be DIFFERENT data types. # type movielist=list(&quot;end game&quot;, 2019, 2783), # the 1st is movie title, the 2nd is year, the 3rd is box office movielist=list(&quot;end game&quot;, 2019, 2783) # print the list movielist ## [[1]] ## [1] &quot;end game&quot; ## ## [[2]] ## [1] 2019 ## ## [[3]] ## [1] 2783 # type str(movielist) to see its structure str(movielist) ## List of 3 ## $ : chr &quot;end game&quot; ## $ : num 2019 ## $ : num 2783 Name each objects in the list using names() function names(movielist)=c(&quot;title&quot;,&quot;year&quot;,&quot;boxoffice&quot;) movielist ## $title ## [1] &quot;end game&quot; ## ## $year ## [1] 2019 ## ## $boxoffice ## [1] 2783 It is a best practice to create list with variable name in the first place to enhance the readability of your code. movielist=list(title=&quot;end game&quot;, year=2019, boxoffice=2783) str(movielist) ## List of 3 ## $ title : chr &quot;end game&quot; ## $ year : num 2019 ## $ boxoffice: num 2783 We can also retrieve the element from list by index; however, we need to use DOUBLE square brackets for retrieve element in list!! # Type movielist[[2]] to retrieve the 2rd element movielist[[2]] ## [1] 2019 The objects in a list is named, we can also retrieve element from list by name. The $ is used to retrieve list element by name. movielist$title ## [1] &quot;end game&quot; Add an element to a list ia also very simple. For example, we want to add a duration of the movie, we can do type movielist$duration=3. movielist$duration=3 str(movielist) ## List of 4 ## $ title : chr &quot;end game&quot; ## $ year : num 2019 ## $ boxoffice: num 2783 ## $ duration : num 3 3.5 Summary The common data structure in R: vector, matrix, list learn to retrieve elements from vector or matrix with index learn to retrieve elements from list with [[]] or $. Learn to use factor to represent both ordered and unodered categorical variables. All elments in vector and matrix must be the same type; list can contain any different type of data. "],["data-frame.html", "Chapter 4 Data Frame 4.1 Define a data.frame manually 4.2 Subsetting data.frame 4.3 Import csv data as data.frame. 4.4 Subsetting data frame 4.5 Write a data frame to your computer 4.6 Summary", " Chapter 4 Data Frame A data frame is more general than a matrix in that different columns can contain different modes of data (numeric, character, factor, logical etc.). We can think of a data frame as a excel sheet where each row represents an observation, while each column represents a variable associated with the observation. Data frames are the basic data structure youll deal with in R. 4.1 Define a data.frame manually Our first exercise is to define a data frame manually to help you familize the functions related to data frame. Suppose we are building a database of diabetes patients. For simplicity, suppose we have only four patients, with the following patient information: patientID = c(1, 2, 3, 4) age = c(25, 34, 28, 52) diabetes = c(&quot;Type1&quot;, &quot;Type2&quot;, &quot;Type1&quot;, &quot;Type1&quot;) status = c(&quot;Poor&quot;, &quot;Median&quot;, &quot;Good&quot;, &quot;Poor&quot;) We want to combine these information into a data frame. The function to construct data fram is as below: mydata = data.frame(col1, col2, col3,) where col1, col2, col3,  are the column of the data frame. Names for each column can be provided with the names function. The following code makes this clear. # this create an empty data frame. # We sometime need to do that when we do not know the ultimate dimension of the data frame. patientdata = data.frame() patientdata = data.frame(patientID, age, diabetes, status) # display the data frame on the screen to visually check the dataset patientdata ## patientID age diabetes status ## 1 1 25 Type1 Poor ## 2 2 34 Type2 Median ## 3 3 28 Type1 Good ## 4 4 52 Type1 Poor We can use str() to examine the structure of the data frame. str() is a very useful function to examine an object in R. We will use this function often. str(patientdata) ## &#39;data.frame&#39;: 4 obs. of 4 variables: ## $ patientID: num 1 2 3 4 ## $ age : num 25 34 28 52 ## $ diabetes : chr &quot;Type1&quot; &quot;Type2&quot; &quot;Type1&quot; &quot;Type1&quot; ## $ status : chr &quot;Poor&quot; &quot;Median&quot; &quot;Good&quot; &quot;Poor&quot; Note that each column of a data frame must have have same data mode, but you can put columns of different modes together to form the data frame. Because data frames are close to what analysts typically think of as datasets, well use the terms columns and variables interchangeably when discussing data frames. 4.2 Subsetting data.frame There are several ways to identify the elements of a data frame. You can use the index notation you used before (for example, with matrices) or you can specify column names. Subset the first 2 column of the patientdata by index: patientdata[,1:2] ## patientID age ## 1 1 25 ## 2 2 34 ## 3 3 28 ## 4 4 52 Subset the first two columns of the data frame by variable names: patientdata[c(&quot;diabetes&quot;, &quot;status&quot;)] ## diabetes status ## 1 Type1 Poor ## 2 Type2 Median ## 3 Type1 Good ## 4 Type1 Poor Subset one specific column (e.g., age) by its name: patientdata$age ## [1] 25 34 28 52 Now, change diabetes and status into factors because they are categorical variables: patientdata$diabetes&lt;-factor(patientdata$diabetes) patientdata$status&lt;-factor(patientdata$status, ordered = TRUE, levels = c(&quot;Poor&quot;, &quot;Median&quot;,&quot;Good&quot;) ) patientdata ## patientID age diabetes status ## 1 1 25 Type1 Poor ## 2 2 34 Type2 Median ## 3 3 28 Type1 Good ## 4 4 52 Type1 Poor str(patientdata) ## &#39;data.frame&#39;: 4 obs. of 4 variables: ## $ patientID: num 1 2 3 4 ## $ age : num 25 34 28 52 ## $ diabetes : Factor w/ 2 levels &quot;Type1&quot;,&quot;Type2&quot;: 1 2 1 1 ## $ status : Ord.factor w/ 3 levels &quot;Poor&quot;&lt;&quot;Median&quot;&lt;..: 1 2 3 1 4.3 Import csv data as data.frame. In most application, we will import dataset (i.e., csv, txt, excel files) from local computer into R as data frame. Here we will learn how to read data into R as data frame. The famous Auto.csv is a very standard dataset for R programming. The Auto.csv contains the basic information of over 300 kinds of Auto. We will learn to import this dataset. I have uploaded the Auto.csv file in the R-studio cloud to aviod the trouble of finding the file in each individuals computer. Look at the files in the bottom right pannel. The file is in csv format, thus we will use read.csv() function. Auto=read.csv(&quot;data/Auto.csv&quot;) # examine the structure of Auto dataset str(Auto) ## &#39;data.frame&#39;: 392 obs. of 10 variables: ## $ mpg : num 18 15 18 16 17 15 14 14 14 15 ... ## $ cylinders : int 8 8 8 8 8 8 8 8 8 8 ... ## $ displacement: num 307 350 318 304 302 429 454 440 455 390 ... ## $ horsepower : int 130 165 150 150 140 198 220 215 225 190 ... ## $ weight : int 3504 3693 3436 3433 3449 4341 4354 4312 4425 3850 ... ## $ acceleration: num 12 11.5 11 12 10.5 10 9 8.5 10 8.5 ... ## $ year : int 70 70 70 70 70 70 70 70 70 70 ... ## $ rating : int 3 1 3 2 1 2 1 2 1 1 ... ## $ origin : chr &quot;US&quot; &quot;US&quot; &quot;US&quot; &quot;US&quot; ... ## $ name : chr &quot;chevrolet chevelle malibu&quot; &quot;buick skylark 320&quot; &quot;plymouth satellite&quot; &quot;amc rebel sst&quot; ... Unlikely excel which shows data in a tabular format, R uses different ways for us to visually examine the data. We can use head() and tail() to examine first/last 6 rows of the data. # print the first 6 rows for visually examining the dataset head(Auto) ## mpg cylinders displacement horsepower weight acceleration year rating origin ## 1 18 8 307 130 3504 12.0 70 3 US ## 2 15 8 350 165 3693 11.5 70 1 US ## 3 18 8 318 150 3436 11.0 70 3 US ## 4 16 8 304 150 3433 12.0 70 2 US ## 5 17 8 302 140 3449 10.5 70 1 US ## 6 15 8 429 198 4341 10.0 70 2 US ## name ## 1 chevrolet chevelle malibu ## 2 buick skylark 320 ## 3 plymouth satellite ## 4 amc rebel sst ## 5 ford torino ## 6 ford galaxie 500 tail(Auto) ## mpg cylinders displacement horsepower weight acceleration year rating ## 387 27 4 151 90 2950 17.3 82 2 ## 388 27 4 140 86 2790 15.6 82 3 ## 389 44 4 97 52 2130 24.6 82 3 ## 390 32 4 135 84 2295 11.6 82 3 ## 391 28 4 120 79 2625 18.6 82 2 ## 392 31 4 119 82 2720 19.4 82 4 ## origin name ## 387 US chevrolet camaro ## 388 US ford mustang gl ## 389 EU vw pickup ## 390 US dodge rampage ## 391 US ford ranger ## 392 US chevy s-10 We can use summary() function to quickly examine the distribution of each variable. summary(Auto) ## mpg cylinders displacement horsepower weight ## Min. : 9.00 Min. :3.000 Min. : 68.0 Min. : 46.0 Min. :1613 ## 1st Qu.:17.00 1st Qu.:4.000 1st Qu.:105.0 1st Qu.: 75.0 1st Qu.:2225 ## Median :22.75 Median :4.000 Median :151.0 Median : 93.5 Median :2804 ## Mean :23.45 Mean :5.472 Mean :194.4 Mean :104.5 Mean :2978 ## 3rd Qu.:29.00 3rd Qu.:8.000 3rd Qu.:275.8 3rd Qu.:126.0 3rd Qu.:3615 ## Max. :46.60 Max. :8.000 Max. :455.0 Max. :230.0 Max. :5140 ## acceleration year rating origin ## Min. : 8.00 Min. :70.00 Min. :1.00 Length:392 ## 1st Qu.:13.78 1st Qu.:73.00 1st Qu.:2.00 Class :character ## Median :15.50 Median :76.00 Median :2.00 Mode :character ## Mean :15.54 Mean :75.98 Mean :2.48 ## 3rd Qu.:17.02 3rd Qu.:79.00 3rd Qu.:3.00 ## Max. :24.80 Max. :82.00 Max. :4.00 ## name ## Length:392 ## Class :character ## Mode :character ## ## ## read.csv() is the function to read csv file into R as a data.frame. When using the function, you need to tell exactly where to find the data file. For example, if Auto.csv is saved in my computer at: C:/Users/lxu25/Dropbox/Teaching/UNL Courses/SCMA 450/code/Auto.csv. We can use the following code to read the file: Auto=read.csv(&quot;C:/Users/lxu25/Dropbox/Teaching/UNL Courses/SCMA 450/code/Auto.csv&quot;) Notice, in the the file directory is /, not \". However, locating this data file can be a hassle, especially when your code is shared with others in your team because the data has a totally different directory in otherss computer. Therefore, it is the best practice to always create a seperate folder for your project and save both code and data in that folder. Since your data is in the same folder of your code, we can simply use the filename to locate the data file. Then share the folder together to others. 4.4 Subsetting data frame Select by rows by index. # type Auto[2,] to select the 2nd row (or called 2nd observation) Auto[2,] ## mpg cylinders displacement horsepower weight acceleration year rating origin ## 2 15 8 350 165 3693 11.5 70 1 US ## name ## 2 buick skylark 320 # type Auto[c(3,5,7),] to select the 3rd, 5th, and 7th rows. Auto[c(3,5,7),] ## mpg cylinders displacement horsepower weight acceleration year rating origin ## 3 18 8 318 150 3436 11.0 70 3 US ## 5 17 8 302 140 3449 10.5 70 1 US ## 7 14 8 454 220 4354 9.0 70 1 US ## name ## 3 plymouth satellite ## 5 ford torino ## 7 chevrolet impala Select column by index. # type Auto[,4] to select the 4th column (i.e., horsepower); head(Auto[,4]) ## [1] 130 165 150 150 140 198 # tpye hist(Auto[,4]) to plot the distribution of horsepower hist(Auto[,4]) # You can customize the histgram to make it look nicer hist(Auto[,4],xlab=&quot;horsepower&quot;, col=&quot;gray&quot;,breaks = 50, main= &quot;frequency of horsepower&quot;) hist() plot the histogram of a variable. You can use ?hist to examine the detail of the function. ?hist # a quick way to look at how to use this function of We can select multiple columns (variables) at the same time. # select the 2nd and 4th column (i.e., cylinders and horsepower ) head(Auto[,c(2,4)]) ## cylinders horsepower ## 1 8 130 ## 2 8 165 ## 3 8 150 ## 4 8 150 ## 5 8 140 ## 6 8 198 We can create a scatter plot between these two variables to see their relationship. This also shows the reason why want to subset data frame. plot(Auto[,c(2,4)]) The scatter plot clearly demonstrates that a higher horsepower is assoicated with a larger number of cylinders. We can also subset the dataset by variable name. We need to use $ for subsetting one variable with its variable name. # Auto$mpg selects the variable mpg # type hist[Auto$mpg] to get its distribution hist(Auto$acceleration) # select multiple columns by name. head( Auto[,c(&quot;horsepower&quot;,&quot;mpg&quot;,&quot;weight&quot;)] ) ## horsepower mpg weight ## 1 130 18 3504 ## 2 165 15 3693 ## 3 150 18 3436 ## 4 150 16 3433 ## 5 140 17 3449 ## 6 198 15 4341 Filter rows by condition: # select all rows with mpg less equal to 12 Auto[Auto$mpg&lt;=12,] ## mpg cylinders displacement horsepower weight acceleration year rating ## 26 10 8 360 215 4615 14.0 70 2 ## 27 10 8 307 200 4376 15.0 70 2 ## 28 11 8 318 210 4382 13.5 70 2 ## 29 9 8 304 193 4732 18.5 70 2 ## 42 12 8 383 180 4955 11.5 71 1 ## 67 11 8 429 208 4633 11.0 72 2 ## 69 12 8 350 160 4456 13.5 72 1 ## 90 12 8 429 198 4952 11.5 73 2 ## 95 12 8 455 225 4951 11.0 73 1 ## 103 11 8 400 150 4997 14.0 73 1 ## 104 12 8 400 167 4906 12.5 73 2 ## 106 12 8 350 180 4499 12.5 73 2 ## 124 11 8 350 180 3664 11.0 73 2 ## origin name ## 26 US ford f250 ## 27 US chevy c20 ## 28 US dodge d200 ## 29 US hi 1200d ## 42 US dodge monaco (sw) ## 67 US mercury marquis ## 69 US oldsmobile delta 88 royale ## 90 US mercury marquis brougham ## 95 US buick electra 225 custom ## 103 US chevrolet impala ## 104 US ford country ## 106 US oldsmobile vista cruiser ## 124 US oldsmobile omega # select all rows with mpg less equal to 12 and greater equal to 11 Auto[Auto$mpg&gt;=11 &amp; Auto$mpg&lt;=12,] ## mpg cylinders displacement horsepower weight acceleration year rating ## 28 11 8 318 210 4382 13.5 70 2 ## 42 12 8 383 180 4955 11.5 71 1 ## 67 11 8 429 208 4633 11.0 72 2 ## 69 12 8 350 160 4456 13.5 72 1 ## 90 12 8 429 198 4952 11.5 73 2 ## 95 12 8 455 225 4951 11.0 73 1 ## 103 11 8 400 150 4997 14.0 73 1 ## 104 12 8 400 167 4906 12.5 73 2 ## 106 12 8 350 180 4499 12.5 73 2 ## 124 11 8 350 180 3664 11.0 73 2 ## origin name ## 28 US dodge d200 ## 42 US dodge monaco (sw) ## 67 US mercury marquis ## 69 US oldsmobile delta 88 royale ## 90 US mercury marquis brougham ## 95 US buick electra 225 custom ## 103 US chevrolet impala ## 104 US ford country ## 106 US oldsmobile vista cruiser ## 124 US oldsmobile omega We can perform operation on existing variable and create new variables and add these new variable into the data frame. E.g., The following code creates a new variable called horsepowerpercylinder, which is horsepower divided by # of cylinders, # and adds to the data frame. Auto$horsepowerpercylinder=Auto$horsepower/Auto$cylinders str(Auto) ## &#39;data.frame&#39;: 392 obs. of 11 variables: ## $ mpg : num 18 15 18 16 17 15 14 14 14 15 ... ## $ cylinders : int 8 8 8 8 8 8 8 8 8 8 ... ## $ displacement : num 307 350 318 304 302 429 454 440 455 390 ... ## $ horsepower : int 130 165 150 150 140 198 220 215 225 190 ... ## $ weight : int 3504 3693 3436 3433 3449 4341 4354 4312 4425 3850 ... ## $ acceleration : num 12 11.5 11 12 10.5 10 9 8.5 10 8.5 ... ## $ year : int 70 70 70 70 70 70 70 70 70 70 ... ## $ rating : int 3 1 3 2 1 2 1 2 1 1 ... ## $ origin : chr &quot;US&quot; &quot;US&quot; &quot;US&quot; &quot;US&quot; ... ## $ name : chr &quot;chevrolet chevelle malibu&quot; &quot;buick skylark 320&quot; &quot;plymouth satellite&quot; &quot;amc rebel sst&quot; ... ## $ horsepowerpercylinder: num 16.2 20.6 18.8 18.8 17.5 ... We can also rename variables using the names() function. # eamine the existing name of the Auto datafile. names(Auto) ## [1] &quot;mpg&quot; &quot;cylinders&quot; &quot;displacement&quot; ## [4] &quot;horsepower&quot; &quot;weight&quot; &quot;acceleration&quot; ## [7] &quot;year&quot; &quot;rating&quot; &quot;origin&quot; ## [10] &quot;name&quot; &quot;horsepowerpercylinder&quot; # change the 11th variable name to power_per_cylinder names(Auto)[11]=&quot;power_per_cylinder&quot; str(Auto) ## &#39;data.frame&#39;: 392 obs. of 11 variables: ## $ mpg : num 18 15 18 16 17 15 14 14 14 15 ... ## $ cylinders : int 8 8 8 8 8 8 8 8 8 8 ... ## $ displacement : num 307 350 318 304 302 429 454 440 455 390 ... ## $ horsepower : int 130 165 150 150 140 198 220 215 225 190 ... ## $ weight : int 3504 3693 3436 3433 3449 4341 4354 4312 4425 3850 ... ## $ acceleration : num 12 11.5 11 12 10.5 10 9 8.5 10 8.5 ... ## $ year : int 70 70 70 70 70 70 70 70 70 70 ... ## $ rating : int 3 1 3 2 1 2 1 2 1 1 ... ## $ origin : chr &quot;US&quot; &quot;US&quot; &quot;US&quot; &quot;US&quot; ... ## $ name : chr &quot;chevrolet chevelle malibu&quot; &quot;buick skylark 320&quot; &quot;plymouth satellite&quot; &quot;amc rebel sst&quot; ... ## $ power_per_cylinder: num 16.2 20.6 18.8 18.8 17.5 ... To delete a variable from data frames: # Delete the variable power_per_cylinder Auto=Auto[,-c(11)] str(Auto) ## &#39;data.frame&#39;: 392 obs. of 10 variables: ## $ mpg : num 18 15 18 16 17 15 14 14 14 15 ... ## $ cylinders : int 8 8 8 8 8 8 8 8 8 8 ... ## $ displacement: num 307 350 318 304 302 429 454 440 455 390 ... ## $ horsepower : int 130 165 150 150 140 198 220 215 225 190 ... ## $ weight : int 3504 3693 3436 3433 3449 4341 4354 4312 4425 3850 ... ## $ acceleration: num 12 11.5 11 12 10.5 10 9 8.5 10 8.5 ... ## $ year : int 70 70 70 70 70 70 70 70 70 70 ... ## $ rating : int 3 1 3 2 1 2 1 2 1 1 ... ## $ origin : chr &quot;US&quot; &quot;US&quot; &quot;US&quot; &quot;US&quot; ... ## $ name : chr &quot;chevrolet chevelle malibu&quot; &quot;buick skylark 320&quot; &quot;plymouth satellite&quot; &quot;amc rebel sst&quot; ... To access the mpg in Auto data frame, we must use $ (e.g., Auto$mpg). If you simply use mpg, R would not know which data frame to look for mpg. But this causes the code too long and hard to read. We can use with() function to avoid that. E.g., plot the scatter plot between weight and mpg with(Auto, plot(weight, mpg) ) The general format of with() function is to: with(DATA FRAME, CODE USING THE DATA FRAME) 4.5 Write a data frame to your computer We can use write.csv() to write the data frame to your local computer. write.csv(Auto,&quot;data/Auto2.csv&quot;, row.names =FALSE) Note, row.names = TRUE will generate an automatic ID (i.e., 1,2,3, ) for each rows. 4.6 Summary While all elements in vector and matrix must be the same type, data.frame allows different columns (i.e., variable) to be different types. use Base R for creating plots. subsetting data.frame using index and variable names. Use read.csv() to read csv file into R as data.frame; learn to subset data.frame. Use write.csv() to write data.frame from R to your local computer. "],["functions.html", "Chapter 5 Functions 5.1 Get the Help Document of A Function 5.2 Call build-in functions in R 5.3 Write Your Own Functions 5.4 Flexible Function 5.5 Excercise 1 5.6 The apply() function family 5.7 Scoping Rule in R 5.8 Excercise", " Chapter 5 Functions Functions are the building blocks in R. There are two ways to pass arguments to a function: by argument names and by position. You will learn to call function through these two ways. In addition, you also will Learn to examine the help document of each function by using ?function_name. Understand the default value of arguments. Open the black box of functions by learning to write your own functions. Understand the scoping rule of R. 5.1 Get the Help Document of A Function You cannot memorize all functions and their usage. We rely on the help documents of the function. Take seq() function as an example. This function can generate a sequence of number. We can type ?seq to get the help document of the function ?seq 5.2 Call build-in functions in R The help document of seq() shows the augments of the function is: seq(from = 1, to = 1, by , length , ) Here from, to, by, length are the argument of the functions. Once we pass value to these arguments, the function will then process these arguments according to its code inside the function. E.g., we want to generate a sequence of even number from 2 to 12. by argument name. seq(from=2,to=12, by=2) ## [1] 2 4 6 8 10 12 by position seq(2,12, 2) ## [1] 2 4 6 8 10 12 5.3 Write Your Own Functions The general format for defining function is as follow: function_name=function(argument1,arugment2, ...){ # Code to Process the arguments return(results) } E.g., our first task is to write a function to calculate the sum square of two numbers. myfun1=function(x1,x2){ return(x1^2+x2^2) } By default, the result from the last line of the function will be the returned result. So we can change the last line as: \\(x_1^2+x_2^2\\). Once we define the function, it is ready to be used just as other functions built-in R. call function by argument name myfun1(x2=2,x1=1) ## [1] 5 call function by position myfun1(1,2) ## [1] 5 5.4 Flexible Function You may notice that some functions have an argument of . This is called flexible function. Lets take a look at an example: We will define a plot function to make a scatter plot between two variable, and add a linear fitted linear to the plot. abplot=function(x,y,...){ plot(x,y,... ) # create a scatter plot abline(lm(y~x)) # add a fitted line } Essentially, anything you passed in the position of  will be passed to the plot() function. We can now call abplot() function with additional arguments as below: Auto=read.csv(&quot;data/Auto.csv&quot;) abplot(Auto$weight, Auto$mpg, type=&quot;p&quot;, xlab=&quot;weight&quot;, ylab=&quot;mpg&quot;,col=&quot;red&quot;) 5.5 Excercise 1 Write a function to calculate the descriptive statistics of an array of numbers (i.e., mean, standard deviation and skewness). Skewness is a measure of symmetry, or more precisely, the lack of symmetry. Below is the formula for computing skewness of a variable. \\[skewness =\\frac{\\sum_{i=1}^n(x_i  \\bar x)^3}{n*\\sigma^3}\\] A variable with skewness close to 0 tend to be symmetry; A variable with negative skewness tend to left skewed; A variable with positive skewness tend to right. mystat=function(x){ avg=mean(x) sd=sd(x) skewness=mean((x-avg)^3)/sd^3 return(c(avg, sd, skewness)) # return mean and std dev as a vector } # acceleration is not as skewed mystat(Auto$acceleration) ## [1] 15.5413265 2.7588641 0.2893592 # horsepower is right skewed mystat(Auto$horsepower) ## [1] 104.469388 38.491160 1.079019 5.6 The apply() function family The apply() function family is very useful for data analysis. The function looks like below: apply(X, MARGIN, FUN, ), where X is 2-dimensional data array, e.g., matrix or a data.frame; MARGIN is a variable defining how the function is applied: when MARGIN=1, it applies over rows, whereas with MARGIN=2, it works over columns FUN, which is the function that you want to apply to the data. apply(Auto[c(&quot;mpg&quot;,&quot;weight&quot;,&quot;horsepower&quot;)], 2, mystat) In addition, lapply() and sapply() are the two variants of apply(). lapply() and sapply() both work over column and return results in different format. # apply function on the column and return results as list lapply(Auto[c(&quot;mpg&quot;,&quot;weight&quot;,&quot;horsepower&quot;)], mystat) ## $mpg ## [1] 23.4459184 7.8050075 0.4536001 ## ## $weight ## [1] 2977.584184 849.402560 0.515616 ## ## $horsepower ## [1] 104.469388 38.491160 1.079019 # apply function on column and return a simplified results sapply(Auto[c(&quot;mpg&quot;,&quot;weight&quot;,&quot;horsepower&quot;)], mystat) ## mpg weight horsepower ## [1,] 23.4459184 2977.584184 104.469388 ## [2,] 7.8050075 849.402560 38.491160 ## [3,] 0.4536001 0.515616 1.079019 5.7 Scoping Rule in R Scoping Rule determines where R should search the value of free variable inside a function. Free variables inside a function is the variables that is neither defined in a function nor the functions argument. Lets look at an example. power=2 myfun2=function(x){ x^power } myfun2(5) ## [1] 25 In the above code, power is a free variable. A good practice is to avoid free variables. In other word, we should define variables needed by a function either through arguments or define locally within the function. For example, we can revise the above function as below: power=2 myfun2=function(x){ power=3 # define power inside the function x^power } # guess, what is the value of myfun2(2) myfun2(2) ## [1] 8 # guess, what is the value of power power ## [1] 2 The scoping rule in R determines that what is the value of power when we call myfun2(2). In R, the program will first search inside the function whether power is defined. If yes, then use the value defined inside the function. Otherwise, the program examine whether power is defined outside the function. Changing the value inside the function will not change the variable outside the function. 5.8 Excercise Support you are working at a bank provides mortgage loan. One important task is to calculate the monthly mortgage payment for any given loan. You can use the following equation to calculate the monthly mortgage payment: \\[M = P ( i(1 + i)^n ) / ( (1 + i)^n - 1)\\] where P = principal loan amount i = annual_interest_rate/12, i.e., i is the monthly interest rate, which is the annual interest rate divided by 12 n = number of months required to repay the loan In this exercise, your goal is define a function for calculating monthly mortgage payment. The function takes three arguments: P(principal), annual_rate, year_repay. The default year_repay is 30, which is the most common mortgage term. "],["flow-control.html", "Chapter 6 Flow Control 6.1 ifelse Statement 6.2 ifelse ifelse Statement 6.3 Exercise 6.4 for loop 6.5 Break Your Loops With break 6.6 Jump to the next cycly with next 6.7 Exercise 6.8 While Loop", " Chapter 6 Flow Control You have written over 500 lines of code. This is a great achievement. All the code we write so far runs from up to the bottom in a linear fashion. Today, we will learn the if, for, and while statements to control the flow of your code. 6.1 ifelse Statement To be or not to be, this is a problem? When solving real problems using computer codes, we will inevitably have to branch our code in different directions based on some criteria. The simplest format for IF-statement in R is: if (logical_expression) { # statement will only be executed if logical_expression is true statement } We can also have else statement as below: if (logical_expression) { # statement1 will be executed if logical_expression is true statement1 } else { # statement2 will be executed if logical_expression is false statement2 } In the above case, statement1 will be excuted if the logical_expression is true; otherwise, statement2 will be executed. Take one example, we will create a door with password. The door will open if you input the correct password, but the door will be closed if you input the incorrect password. pw=&quot;2497&quot; pw_entered=readline(&quot;Please enter the password: &quot;) if (pw_entered==pw){ print(&quot;The door is opened. Welcome!&quot;) } else { print(&quot;Password wrong. Door closed!&quot;) } In this case, the logical expression evaluates whether pw_entered==pw is true or not. If true, then the program proceeds to print(The door is opened. Welcome!); If not true, then the program proceeds to print(Password wrong. Door closed!). 6.2 ifelse ifelse Statement The ifelse statement is great to program the binary outcome (e.g., correct password or incorrect password). However, sometime we need to deal with more than two outcomes. In this case, we need to use the ifelse ifelse statement: if ( logical_expression1) { statement1 } else if ( logical_expression2) { statement2 } else { statement3 } logical_expression1 and logical_expression2 are a set of mutually exclusive criteria; only one statement will be executed depending on which logical_expression is true. You can have more else as needed. 6.3 Exercise In data analysis, we often want to bin a continuous variable into categorical of low, median, high or even more category. For example, we want to classify Auto as low, median, high gas efficiency based on mpg: if mpg&lt;22, the efficiency is low; if 26&gt;mpg&gt;=22, then the efficiency is median; if mpg&gt;=26, then the efficiency is high. mpg=23 if (mpg&lt;22) { efficiency=&quot;low&quot; } else if (mpg&lt;26) { efficiency=&quot;median&quot; } else{ efficiency=&quot;high&quot; } efficiency ## [1] &quot;median&quot; Note that we did not need to write mpg&gt;=22 &amp; mpg&lt;26 in the second criteria since the second criteria will only be evaluated when mpg&gt;=22. 6.4 for loop In computer programming, we sometime want to do things repetitively. For example, there are 10 data files, each corresponding to a specific year. Want to read all these 10 files into R; or we will visit 100 different websites to scrape the data from web. Loop allows the program to go back to previous code and do things repetitively. In R programming, a for-loop is used to iterate over a vector. The syntax of for loop is for (val in sequence){ statement } Here, sequence is a vector and val takes on each of its value during the loop. val is also called iterator because it will iterate every elements in sequence. In each iteration, statement is evaluated. Lets look at one simple example. For example, print 1 to 10 on the screen. This is a repetitive task, i.e., printing a number on screen for 10 times. We can use for loop to achieve this. for (i in 1:10){ print(i) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 In this example, 1:10 generates a vector from 1 to 100. i will iterate every value from 1 to 10 and be printed on the screen. The sequence can also be a character vector. For example, the following code will print every elements of the character vector on the screen. students=c(&quot;John&quot;,&quot;Lily&quot;,&quot;Leon&quot;,&quot;Brandon&quot;) for (i in students){ print(i) } ## [1] &quot;John&quot; ## [1] &quot;Lily&quot; ## [1] &quot;Leon&quot; ## [1] &quot;Brandon&quot; In the above code, i will iterate over the students vector; and print(i) will be excuted for 4 times, with i taking the value of John, Lily, Leon, Brandon. For example, we want to calculate the sum square from 1 to 100. sum=0 # initize the sum as 0 # we will add the square of a number (1-100) to sum for (i in 1:100){ sum=sum+i^2 } sum ## [1] 338350 In this example, i will iterate every value from 1 to 100; and the statement will thus be excuted for 100 times, with i taking the value from 1 to 100. 6.5 Break Your Loops With break As seen in above examples, for-loop requires the program to iterate every element in the vector. However, you can break your loop with break. When the R encounters a break, it will exit the loop immediately. For example, in the printing students name example, we will exit the loop if the iterator takes the value Leon and print Leon is not student. students=c(&quot;John&quot;,&quot;Lily&quot;,&quot;Leon&quot;,&quot;Brandon&quot;) for (i in students){ if (i==&quot;Leon&quot;){ print(&quot;Leon is not student.&quot;) break } else{ print(i) } } ## [1] &quot;John&quot; ## [1] &quot;Lily&quot; ## [1] &quot;Leon is not student.&quot; 6.6 Jump to the next cycly with next The above code shows that we can use break to end the loop if the iterator meets certain criteria. However, in some cases, we do not want to end the loop completely, but to skip the particular iteration. We can use next to discontinue a particular iteration and jumps to the next cycle. students=c(&quot;John&quot;,&quot;Lily&quot;,&quot;Leon&quot;,&quot;Brandon&quot;) for (i in students){ if (i==&quot;Leon&quot;){ print(&quot;Leon is not student!&quot;) next } else{ print(i) } } ## [1] &quot;John&quot; ## [1] &quot;Lily&quot; ## [1] &quot;Leon is not student!&quot; ## [1] &quot;Brandon&quot; 6.7 Exercise Lets revisit the door password problem. In this exercise, we want to design the password in such way that you have three chances to input the passwords. If you enter the password correctly within the three times, the door will open; you have the opportunity to re-enter the password before you running out of the three chances; if you did not enter the correct password within the three trials, the door will be closed. This is a repetitive task because you are asked to enter the password for three times. We can thus use for-loop for this purpose. Verison 1: pw=&quot;2497&quot; for (i in 1:3){ pw_entered=readline(&quot;Please enter the password: &quot;) if (pw_entered==pw){ print(&quot;The door is opened. Welcome!&quot;) break } else { print(&quot;Password wrong. Please re-enter the password: &quot;) } } Verison 2: When i=3, the code should show that the door is locked due to too many failed trials, rather than asking for re-enter the password. pw=&quot;2497&quot; for (i in 1:3){ pw_entered=readline(&quot;Please enter the password: &quot;) if (pw_entered==pw){ print(&quot;The door is opened. Welcome!&quot;) break } else if(i!=3){ print(&quot;Password wrong. Please re-enter the password: &quot;) } else { print(&quot;Password wrong. Door closed.&quot;) } } 6.8 While Loop In R programming, while loops are used to loop until a specific condition is met. The while loop is also used for repetitive task. The syntax for while-loop is as below: while (test_expression) { statement } Here, test_expression is evaluated and the body of the loop is entered if the result is TRUE. Lets look at how to calculate the sum square from 1 to 100 using while loop. sum=0 # initize the sum as 0 i=1 # initize the iterator # we will add the square of a number (1-100) to sum while (i&lt;=100){ sum=sum+i^2 i=i+1 } sum ## [1] 338350 Lets revist the password door exercise. You will have 3 chances to enter the correct password to open the door. This time, implement this with while-loop. pw=&quot;2497&quot; i=1 # initialize the iterator while (i &lt;= 3){ pw_entered=readline(&quot;Please enter the password: &quot;) if (pw_entered==pw){ print(&quot;The door is opened. Welcome!&quot;) break } else if(i!=3){ print(&quot;Password wrong. Please re-enter the password: &quot;) } else { print(&quot;Password wrong. Door closed.&quot;) } i=i+1 # increase the iterator by 1 at the end } As seen, it is much easily to use for-loop for iterating over a fixed sequence because we do not need to manually update the iterator. Typically, we use while-loop if we do not how many iteration will be conducted; and use for-loop if we know how many iteration to be conducted. Also, break/next work similarly with while-loop to exit the while-loop or to jump to the next iteration within the while-loop, respectively. "],["references.html", "References", " References "]]
